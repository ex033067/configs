" leader keys
let mapleader=','
let maplocalleader='\'

" Start with vim defaults
if filereadable(expand("$VIMRUNTIME/defaults.vim"))
    unlet! skip_defaults_vim
    source $VIMRUNTIME/defaults.vim
endif


" ==================================================
" Plugins
" ==================================================
" install vim-plug:
" curl -fLo ~/.vim/autoload/plug.vim --create-dirs \
"    https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim

call plug#begin('~/.vim/bundle')
Plug 'unblevable/quick-scope'
Plug 'viniciusban/vim-polyglot'  | " up to date syntax files
Plug 'viniciusban/vim-simple-onblack-colorschemes'
Plug 'luochen1990/rainbow' | " colorize parentheses
Plug 'ap/vim-css-color'  | " show the color in CSS
Plug 'tpope/vim-commentary'  | " gcc, gc<motion>, {Visual}gc
Plug 'machakann/vim-sandwich'  | " sa, sd, sr
Plug 'andymass/vim-matchup'  | " %, g%, a%, i%, and more
Plug 'kana/vim-textobj-user' | " required by other text object plugins
Plug 'kana/vim-textobj-indent' | " ai, ii
Plug 'glts/vim-textobj-comment' | " ac, ic (remapped below to...)
Plug 'bps/vim-textobj-python' | " ac, ic, af, if.
Plug 'jeetsukumaran/vim-pythonsense' | " ad, id (docstring objects). See https://github.com/viniciusban/myconfigs/issues/1
Plug 'inkarkat/vim-ReplaceWithRegister'  | " <register>gr{motion}, {Visual}<register>gr
Plug 'davidhalter/jedi-vim'
Plug 'SirVer/ultisnips'
Plug 'honza/vim-snippets'
Plug 'viniciusban/vim-ft-markdown'
Plug 'mattn/emmet-vim'
Plug 'tpope/vim-fugitive'
Plug 'junegunn/fzf', {'dir': '~/.vim/bundle/fzf', 'do': './install --all'}
Plug 'junegunn/fzf.vim'
Plug 'scrooloose/nerdtree'
Plug 'majutsushi/tagbar'
call plug#end()

" tagbar
let g:tagbar_ctags_bin = 'ctags'
let g:tagbar_autofocus = 1
let g:tagbar_position = 'leftabove vertical'
let g:tagbar_case_insensitive = 1

" quick-scope
let g:qs_enable=0  |" start plugin with highlight disabled

" rainbow
let g:rainbow_active = 0

" vim-text-object-comment
omap aC <Plug>(textobj-comment-a)
xmap aC <Plug>(textobj-comment-a)
omap iC <Plug>(textobj-comment-i)
xmap iC <Plug>(textobj-comment-i)

" vim-textobj-python
let g:is_pythonsense_suppress_object_keymaps = 1
let g:is_pythonsense_suppress_motion_keymaps = 1

" jedi-vim
let g:jedi#popup_on_dot=0
let g:jedi#show_call_signatures_delay=100
let g:jedi#goto_command = 'gD' |"# '<localleader>jd'
let g:jedi#goto_assignments_command = '<localleader>jg'
let g:jedi#goto_stubs_command = '<localleader>js'
let g:jedi#rename_command = '<localleader>jr'
let g:jedi#usages_command = '<localleader>jn'

" ultisnips
let g:UltiSnipsSnippetDirectories=[$HOME.'/src/vim-snippets']

" emmet
let g:user_emmet_leader_key = '<C-\>'

" NERDTree
let NERDTreeIgnore=['__pycache__[[dir]]']
let NERDTreeHijackNetrw = 0


" ==================================================
" my own functions
" ==================================================

function! Ban_Run(command)
    " Run an external command using internal or external terminal

    if !exists('g:ban_run_internal')
        if has('gui_running')
            let g:ban_run_internal = 1
        elseif has('nvim')
            let g:ban_run_internal = 1
        else
            let g:ban_run_internal = 0
        endif
    endif

    let quote = "'"
    if g:ban_run_internal == 1
        if has('nvim')
            let prefix = 'tabnew | terminal '. &shell .' -c ' . quote
            let suffix = quote
        else
            let prefix = 'tabnew | terminal ++curwin ++shell '
            let suffix = ''
        endif
        let command = substitute(a:command, quote, "'\"\\'\"'", 'g')
        let command = substitute(command, '#', '\\#', 'g')
    else
        let prefix = '!'
        let command = a:command
        let suffix = ''
    endif

    return prefix . command . suffix
endfunction

function! BanPython_GetCurrentPythonClassName()
    execute "normal ms$?^class \<Enter>0w"
    nohls
    let class_name = expand('<cword>')
    execute 'normal g`s'
    return l:class_name
endfunction

function! BanPython_GetCurrentPythonMethodName()
    execute 'normal ms$?^ \+\(def\|async def\) \+test\w\+(\_s\{-}self?e' . "\<Enter>" . '3b'
    nohls
    let method_name = expand('<cword>')
    execute 'normal g`s'
    return l:method_name
endfunction

function! BanPython_GetCurrentPythonFunctionName()
    execute 'normal ms$?^\(def\|async def\) \+test\w\+(?e' . "\<Enter>" . 'b'
    nohls
    let function_name = expand('<cword>')
    execute 'normal g`s'
    return l:function_name
endfunction

function! BanPython_MakeValidPythonTestName()
    " Transform a phrase into a test method name.
    "
    " Transform this:
    "   show user name
    " Into this:
    "   def test_show_user_name(self):
    "
    let x=getline('.')
    let x=substitute(x, '\(\w\) ', '\1_', 'ge')
    let x=substitute(x, '-', '_', 'ge')
    let x=substitute(x, '\(\S\+\)', 'def test_\1(self):', '')
    call setline('.', x)
endfunction

function! BanPython_GetTestSeparators(command)
    if a:command =~ 'unittest'
        let path_separator = '.'
        let expand_string = '%:.:r'
    elseif a:command =~ '--pyargs'
        let path_separator = '.'
        let expand_string = '%:.:r'
    elseif a:command =~ 'manage.py test'
        let path_separator = '.'
        let expand_string = '%:.:r'
    else
        let path_separator = '/'
        let expand_string = '%:.'
    endif

    if a:command =~ 'pytest'
        let class_separator = '::'
    else
        let class_separator = '.'
    endif

    return [path_separator, class_separator, expand_string]
endfunction

function! BanPython_SetAllSuiteAsTestTarget()
    let g:test_target = ''
endfunction

function! BanPython_SetCurrentPackageAsTestTarget(command)
    let [path_sep, _, _] = BanPython_GetTestSeparators(a:command)
    let g:test_target = substitute(expand('%:.:h'), '/', path_sep, 'g')
endfunction

function! BanPython_SetCurrentModuleAsTestTarget(command)
    let [path_sep, _, expand_arg] = BanPython_GetTestSeparators(a:command)
    let g:test_target = substitute(expand(expand_arg), '/', path_sep, 'g')
endfunction

function! BanPython_SetCurrentClassAsTestTarget(command)
    let [path_sep, class_sep, expand_arg] = BanPython_GetTestSeparators(a:command)
    let target = expand(expand_arg) . class_sep . BanPython_GetCurrentPythonClassName()
    let g:test_target = substitute(target, '/', path_sep, 'g')
endfunction

function! BanPython_SetCurrentMethodAsTestTarget(command)
    let [path_sep, class_sep, expand_arg] = BanPython_GetTestSeparators(a:command)
    let target = expand(expand_arg) . class_sep . BanPython_GetCurrentPythonClassName() . class_sep . BanPython_GetCurrentPythonMethodName()
    let g:test_target = substitute(target, '/', path_sep, 'g')
endfunction

function! BanPython_SetCurrentFunctionAsTestTarget(command)
    let [path_sep, class_sep, expand_arg] = BanPython_GetTestSeparators(a:command)
    let target = expand(expand_arg) . class_sep . BanPython_GetCurrentPythonFunctionName()
    let g:test_target = substitute(target, '/', path_sep, 'g')
endfunction

function! BanPython_RunCurrentTestMethod(command)
    call BanPython_SetCurrentMethodAsTestTarget(a:command)
    let test_command = BanPython_BuildTestCommand(a:command, g:test_target)
    execute Ban_Run('run-test '. test_command)
endfunction

function! BanPython_RunCurrentTestFunction(command)
    call BanPython_SetCurrentFunctionAsTestTarget(a:command)
    let test_command = BanPython_BuildTestCommand(a:command, g:test_target)
    execute Ban_Run('run-test '. test_command)
endfunction

function! BanPython_RunCurrentTestCase(command)
    call BanPython_SetCurrentClassAsTestTarget(a:command)
    let test_command = BanPython_BuildTestCommand(a:command, g:test_target)
    execute Ban_Run('run-test '. test_command)
endfunction

function! BanPython_RunCurrentTestModule(command)
    call BanPython_SetCurrentModuleAsTestTarget(a:command)
    let test_command = BanPython_BuildTestCommand(a:command, g:test_target)
    execute Ban_Run('run-test '. test_command)
endfunction

function! BanPython_RunCurrentTestPackage(command)
    call BanPython_SetCurrentPackageAsTestTarget(a:command)
    let test_command = BanPython_BuildTestCommand(a:command, g:test_target)
    execute Ban_Run('run-test '. test_command)
endfunction

function! BanPython_RunAllTestSuite(command)
    call BanPython_SetAllSuiteAsTestTarget()
    let test_command = BanPython_BuildTestCommand(a:command, '')
    execute Ban_Run('run-test '. test_command)
endfunction

function! BanPython_BuildTestCommand(command, target)
    " The {{ target }} part is used mainly with 'make test'.
    " As you know we can't pass arguments to 'make' as we do to shell scripts.
    " The easiest way is setting an environment variable and call 'make'.
    " So, we use the 'var=value command' syntax.
    "
    " Let's see an example.
    "
    " command: target='--pyargs {{ target }}' make test
    " target: some.package.module::Class::test_method
    "
    " Becomes
    "
    " target='--pyargs some.package.module::Class::test_method' make test
    "

    if a:command =~ '{{ target }}'
        let x = substitute(a:command, '{{ target }}', a:target, 'g')
        return 'eval "'. x .'"'
    endif
    return a:command .' '. a:target
endfunction

function! BanPython_TransformSelectedTextIntoFilename()
    let unnamed_register = @"
    execute 'normal gvy'
    let selected_text = @"
    let @" = unnamed_register
    let filename = substitute(selected_text, '\.', '/', 'ge') .'.py'
    return filename
endfunction

function! BanChangeColorscheme()
    let colors = ["amber_simple_onblack", "brown_simple_onblack", "green_simple_onblack", "red_simple_onblack", "white_simple_onblack"]
    let next_color = get(colors, index(colors, g:colors_name) + 1, colors[0])
    execute "colorscheme " . next_color
endfunction


" ==================================================
" Autocommands
" ==================================================

augroup aug_terminal_mode
    au!
    silent! autocmd TerminalWinOpen * setlocal nonumber norelativenumber
    silent! autocmd TerminalOpen * setlocal nonumber norelativenumber
augroup END

augroup aug_ft_css
    au!
    autocmd FileType css setlocal tabstop=2
augroup END

augroup aug_ft_html
    au!
    autocmd FileType html,htmldjango setlocal tabstop=2
    autocmd FileType html,htmldjango let b:match_words = '<:>,{{:}},{%:%},{:},[:],(:),<!--:-->' .
        \ ',<\@<=\([^/][^ \t>]*\)[^>]*\%(>\|$\):<\@<=/\1>' .
        \ ',{% block:{% endblock,{% if:{% endif,{% for:{% endfor,{% macro:{% endmacro' .
        \ ',{% call:{% endcall,{% filter:{% endfilter,{% set:{% endset'
augroup END

augroup aug_ft_json
    au!
    autocmd FileType json setlocal tabstop=2
augroup END

augroup aug_ft_php
    au!
    autocmd FileType php setlocal foldmethod=marker foldmarker={,}
augroup END

augroup aug_ft_python
    au!
    autocmd FileType python call FtPython()
augroup END

function! FtPython()
    setlocal foldmethod=indent

    " set makeprg option
    let b:default_makeprg = ''
    let b:_makeprg = b:default_makeprg
    if exists('$VIM_MAKEPRG')
        if $VIM_MAKEPRG == 'default'
            let b:_makeprg = b:default_makeprg
        else
            let b:_makeprg = $VIM_MAKEPRG
        endif
    elseif filereadable('Makefile')
        let b:_makeprg = 'TARGET=%\ make\ --no-print-directory\ --silent'
    elseif executable('flake8')
        let b:_makeprg = 'flake8'
    elseif executable('pylint')
        let b:_makeprg = 'pylint'
    endif
    execute 'setlocal makeprg='.b:_makeprg
    unlet b:_makeprg

    " set equalprg option
    let b:default_equalprg = '~/.local/bin/python-style'
    let b:_equalprg = b:default_equalprg
    if exists('$VIM_EQUALPRG')
        if $VIM_EQUALPRG == 'default'
            let b:_equalprg = b:default_equalprg
        else
            let b:_equalprg = $VIM_EQUALPRG
        endif
    elseif filereadable('Makefile')
        let b:_equalprg = 'make\ --no-print-directory\ --silent\ pep8'
    endif
    execute 'setlocal equalprg='.b:_equalprg
    unlet b:_equalprg

    map <buffer> <localleader>= :update<CR><Esc>gg=G
    map <buffer> <localleader>m :update<CR>:make %<CR>

    " Mappings for classes, functions and docstrings text-objects
    xmap <buffer> ic <Plug>(textobj-python-class-i)
    omap <buffer> ic <Plug>(textobj-python-class-i)
    xmap <buffer> ac <Plug>(textobj-python-class-a)
    omap <buffer> ac <Plug>(textobj-python-class-a)
    xmap <buffer> if <Plug>(textobj-python-function-i)
    omap <buffer> if <Plug>(textobj-python-function-i)
    xmap <buffer> af <Plug>(textobj-python-function-a)
    omap <buffer> af <Plug>(textobj-python-function-a)
    xmap <buffer> ad <Plug>(PythonsenseOuterDocStringTextObject)
    omap <buffer> ad <Plug>(PythonsenseOuterDocStringTextObject)
    xmap <buffer> id <Plug>(PythonsenseInnerDocStringTextObject)
    omap <buffer> id <Plug>(PythonsenseInnerDocStringTextObject)

    " edit selected module name
    xmap <localleader>f :<C-U>let @g = BanPython_TransformSelectedTextIntoFilename() <CR>

    " Mappings to help with tests (this is a big section).
    " All mappings are prefixed with \t.
    if !exists('g:test_command')
        let g:test_command=''
        if $VIM_TEST_COMMAND != ''
            let g:test_command = $VIM_TEST_COMMAND
        else
            if executable('pytest')
                " makes pytest the default test runner if it is present
                let g:test_command = 'pytest --pyargs'
            endif
        endif
    endif
    if !exists('g:test_target')
        let g:test_target = ''
    endif

    " \tt run tests in current vim session.
    " \TT run tests in tmux next pane.
    nmap <localleader>tt :wall <CR>:execute Ban_Run('run-test '. BanPython_BuildTestCommand(g:test_command, g:test_target))<CR>
    nmap <silent> <localleader>TT :update<CR>:execute '!tmux send-keys -t .+ -l "' .g:test_command. ' ' .g:test_target. '"'<CR>:execute '!tmux send-keys -t .+ Enter'<CR><CR>
    nmap t<CR> <localleader>tt
    nmap T<CR> <localleader>TT

    " \tC configure the test command (along with its arguments).
    " Examples:
    "   - pytest --pyargs
    "   - python manage.py test -v 2
    "   - python -m unittest
    map <localleader>tC :let g:test_command='<c-r>=g:test_command<cr>'

    " \tn Make a test name from current line contents
    map <buffer> <localleader>tn :call BanPython_MakeValidPythonTestName() <CR>

    " Mark the target and run tests
    map <buffer> <localleader>ta :wall <CR>:call BanPython_RunAllTestSuite(g:test_command) <CR>
    map <buffer> <localleader>tp :wall <CR>:call BanPython_RunCurrentTestPackage(g:test_command) <CR>
    map <buffer> <localleader>t% :wall <CR>:call BanPython_RunCurrentTestModule(g:test_command) <CR>
    map <buffer> <localleader>tc :wall <CR>:call BanPython_RunCurrentTestCase(g:test_command) <CR>
    map <buffer> <localleader>tm :wall <CR>:call BanPython_RunCurrentTestMethod(g:test_command) <CR>
    map <buffer> <localleader>tf :wall <CR>:call BanPython_RunCurrentTestFunction(g:test_command) <CR>

    " Only mark the target
    map <buffer> <localleader>TA :wall <CR>:call BanPython_SetAllSuiteAsTestTarget() <CR>:echo g:test_target. ' set as test target.'<CR>
    map <buffer> <localleader>TP :wall <CR>:call BanPython_SetCurrentPackageAsTestTarget(g:test_command) <CR>:echo g:test_target. ' set as test target.'<CR>
    map <buffer> <localleader>T% :wall <CR>:call BanPython_SetCurrentModuleAsTestTarget(g:test_command) <CR>:echo g:test_target. ' set as test target.'<CR>
    map <buffer> <localleader>TC :wall <CR>:call BanPython_SetCurrentClassAsTestTarget(g:test_command) <CR>:echo g:test_target. ' set as test target.'<CR>
    map <buffer> <localleader>TM :wall <CR>:call BanPython_SetCurrentMethodAsTestTarget(g:test_command) <CR>:echo g:test_target. ' set as test target.'<CR>
    map <buffer> <localleader>TF :wall <CR>:call BanPython_SetCurrentFunctionAsTestTarget(g:test_command) <CR>:echo g:test_target. ' set as test target.'<CR>

    " copy current filename and function/method to register z in pytest format (JOE specific)
    nmap <silent> <localleader>tr :let cursorpos = getcurpos() <CR>:call search('def test', 'besc') <CR>:execute 'normal bye' <CR>:let @z = substitute(expand('%'), '.*joe/tests/', '', '').'::'.getreg('"') <CR>:call setpos('.', cursorpos) <CR>:let test_cmd = "t " .trim(getreg('z'))<CR>:execute '!tmux send-keys -t JOE:src.1 -l "' .test_cmd. '"'<CR>:execute '!tmux send-keys -t JOE:src.1 Enter'<CR><CR>

    syn keyword pythonTodo          TODO FIXME NOTE contained
    hi! link pythonBuiltin Statement
    hi! link pythonDocTest2 Comment
endfunction

augroup aug_ft_make
    au!
    autocmd FileType make setlocal noexpandtab
augroup END

augroup aug_ft_fugitive
    au!
    autocmd FileType fugitive setlocal cursorline
augroup END

augroup aug_ft_gitcommit
    au!
    autocmd FileType gitcommit setlocal foldenable foldmethod=syntax
    autocmd BufRead COMMIT_EDITMSG setlocal nocursorline
    autocmd BufRead COMMIT_EDITMSG call execute(['normal gg'])
    " go to next/prev file in commit
    autocmd FileType gitcommit nmap <silent> <buffer> ]] :call search('^diff\\|^# On branch', "z")<CR>ztzv
    autocmd FileType gitcommit nmap <silent> <buffer> [[ :call search('^diff\\|^# On branch', "b")<CR>ztzv
    " go to next/prev change
    autocmd FileType gitcommit nmap <silent> <buffer> ]c :call search('^@@', "z")<CR>zt
    autocmd FileType gitcommit nmap <silent> <buffer> [c :call search('^@@', "b")<CR>zt
augroup END

augroup aug_list_items
    au!

    " add item
    autocmd FileType markdown,text nmap <buffer> <localleader>i o- [ ]
    autocmd FileType markdown,text imap <buffer> <localleader>i - [ ]

    " mark item as doing/done
    autocmd FileType markdown,text nmap <silent> <buffer> <localleader>* :keeppatterns :s/^\(\s*- \[\).]/\1*]/<CR>
    autocmd FileType markdown,text nmap <silent> <buffer> <localleader>x :keeppatterns :s/^\(\s*- \[\).]/\1x]/<CR>

    " go to next/previous list item (any level)
    autocmd FileType markdown,text nmap <silent> <buffer> ]- :call search('^\s*- ', "z")<CR>
    autocmd FileType markdown,text nmap <silent> <buffer> [- :call search('^\s*- ', "b")<CR>

    " go to next/previous sibling
    autocmd FileType markdown,text nmap <silent> <buffer> ]= ^:call search("^". strpart(getline("."), 0, col(".")), "z")<CR>
    autocmd FileType markdown,text nmap <silent> <buffer> [= ^:let _pat=strpart(getline("."), 0, col("."))<CR>0:call search("^". _pat, "b")<CR>

    " go to parent
    autocmd FileType markdown,text nmap <silent> <buffer> [_ ^:call search('\%<' .col("."). 'c\S', "b")<CR>
augroup END

augroup aug_viniciusban_journal
    au!

    " Journal file v2 behaviour and functions
    " ---------------------------------------

    autocmd BufReadPost *journal.md inoremap <buffer> <localleader>ct <C-o>:call BanJournal_CreateTask($JOURNAL_PROJECT)<CR>
    autocmd BufReadPost *journal.md nmap <buffer> <localleader>st :call BanJournal_StartCurrentTask()<CR>
    autocmd BufReadPost *journal.md nmap <buffer> <localleader>et :call BanJournal_EndCurrentTask()<CR>
    autocmd BufReadPost *journal.md inoremap <buffer> <localleader>ts <C-o>:call BanJournal_AddTimestampNoteToCurrentLine()<CR>

    " TODO Start a new daily overview:
    "   - add a new "_daily_YYYYMMDD_www_ daily YYYY-MM-DD Www" task

    " TODO Start a new timesheet:
    "   - add a new "_timesheet_YYYYMMDD_www_ timesheet YYYY-MM-DD Www" task

    " New journal file support functions
    " ----------------------------------

    function! BanJournal_ShowMappings()
        return 'Tasks: \ct(create) \st(start) \et(end) \ts(timestamp note)'
    endfunction

    function! BanJournal_CreateTask(project)
        " Create a task in current line

        let lnum = line('.')
        call BanJournal_DoCreateTask(lnum, a:project, trim(getline(lnum)))
        call cursor(lnum, col('$'))
    endfunction

    function! BanJournal_StartCurrentTask()
        " Create the task section in DOING. Keep it in BACKLOG.

        let current_line = line('.')
        call BanJournal_DoStartTaskAtLine(current_line)
        let task_code = BanJournal_GetTaskCodeForLine(current_line)
        let task_section = BanJournal_GetTaskSectionInterval(task_code)
        call cursor(task_section[1], 1000)
    endfunction

    function! BanJournal_EndCurrentTask()
        let current_line = line('.')
        let task_code = BanJournal_GetTaskCodeForLine(current_line)
        if task_code == ''
            echom 'Error: Not a task'
            return
        endif
        call BanJournal_DoEndTask(current_line, task_code)
        normal zv
    endfunction

    function! BanJournal_AddTimestampNoteToCurrentLine(description = '')
        let lnum = line('.')
        call BanJournal_AddTimestampNoteToLine(lnum, a:description)
        call cursor(lnum, col('$'))
    endfunction

    function! BanJournal_DoCreateTask(lnum, project, description)
        " Create a task in line `lnum`.
        "
        " Format: _{project}_{date}_{suffix}_

        let template = '- [ ] {task_code} {description}'
        let task_code = BanJournal_BuildTaskCode(a:project)
        let new_line = template

        let new_line = substitute(new_line, '{task_code}', task_code, '')
        let new_line = substitute(new_line, '{description}', a:description, '')

        call setline(a:lnum, new_line)
    endfunction

    function! BanJournal_DoStartTaskAtLine(lnum)
        " Start the task at `lnum` line.

        let lnum = line('.')
        call BanJournal_AddStartDateToTaskTitleAtLine(lnum)
        call BanJournal_MarkTaskAtLineAsDoing(lnum)
        call BanJournal_CopyTaskAtLineToDoing(lnum)
        call BanJournal_AddTimestampNoteWhenStartingTaskAtLine(lnum)
        normal zx
    endfunction

    function! BanJournal_DoEndTask(lnum, task_code)
        " Remove from BACKLOG. Move from DOING to DONE.

        let task_item_line = BanJournal_FindTaskItemWithTaskCode(a:task_code)
        execute task_item_line . 'delete _'
        call BanJournal_MoveTaskToDone(a:task_code)
        call BanJournal_AddEndDateToTaskTitle(a:task_code)
        call BanJournal_AddTimestampNoteWhenFinishingTask(a:task_code)
    endfunction

    function! BanJournal_AddTimestampNoteToLine(lnum, description = '')
        let template = '{today} {weekday} {now} {task_code}{description}'
        let new_line = template

        let task_code = BanJournal_GetTaskCodeForLine(a:lnum)
        if empty(a:description)
            let description = ''
        else
            let description = ' '. a:description
        endif

        let new_line = substitute(new_line, '{today}', strftime("%Y-%m-%d"), '')
        let new_line = substitute(new_line, '{weekday}', strftime("%a"), '')
        let new_line = substitute(new_line, '{now}', strftime("%H:%M"), '')
        let new_line = substitute(new_line, '{task_code}', task_code, '')
        let new_line = substitute(new_line, '{description}', description, '')

        call setline(a:lnum, new_line)
    endfunction

    function! BanJournal_BuildTaskCode(project)
        " Assemble different pieces to build a task code.
        let template = '_{project}_{today}_{suffix}_'
        let suffix = BanJournal_CreateRandomCodeWithLength(2)

        let task_code = template
        let task_code = substitute(task_code, '{project}', a:project, '')
        let task_code = substitute(task_code, '{today}', strftime("%y%m%d"), '')
        let task_code = substitute(task_code, '{suffix}', suffix, '')
        return task_code
    endfunction

    function! BanJournal_CreateRandomCodeWithLength(length)
        " Create a random code with `length` chars.
        let chars = 'abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'
        let len_chars = len(chars)
        let result = []
        for _ in range(a:length)
            let i = rand() % len_chars
            call add(result, chars[i])
        endfor
        return join(result, '')
    endfunction

    function! BanJournal_FindTaskItemWithTaskCode(task_code)
        let item_line = search('^- \[.\] '. a:task_code, 'n')
        return item_line
    endfunction

    function! BanJournal_GetTaskCodeForLine(lnum)
        let task_code = BanJournal_GetTaskCodeFromItemList(a:lnum)
        if task_code == ''
            let task_code = BanJournal_GetTaskCodeFromInsideTask(a:lnum)
        endif

        return task_code
    endfunction

    function! BanJournal_GetTaskCodeFromItemList(lnum)
        let pattern = '^- \[.\] \(_\w\+_\)\W'
        let matches = matchlist(getline(a:lnum), pattern)
        if empty(matches)
            return ''
        endif
        return matches[1]
    endfunction

    function! BanJournal_GetTaskCodeFromInsideTask(lnum)
        " Task codes are in level 2 heading
        let pattern = '^## \(_\w\+_\)\W'
        let initial_line = line('.')

        call cursor(a:lnum, 1)
        let task_first_line = search(pattern, 'bcnW')
        call cursor(initial_line, 1)

        if task_first_line == 0
            return
        endif

        let matches = matchlist(getline(task_first_line), pattern)
        if empty(matches)
            return ''
        endif
        return matches[1]
    endfunction

    function! BanJournal_AddStartDateToTaskTitleAtLine(lnum)
        " Add note in task about when started doing: (#start:YYYY-MM-DD)
        let line_template = '{previous_contents} {note}'
        let note_template = '(#start:{today})'

        let note = note_template
        let note = substitute(note, '{today}', strftime('%Y-%m-%d'), '')

        let new_line = line_template
        let new_line = substitute(new_line, '{previous_contents}', getline(a:lnum), '')
        let new_line = substitute(new_line, '{note}', note, '')

        call setline(a:lnum, new_line)
    endfunction

    function! BanJournal_MarkTaskAtLineAsDoing(lnum)
        let line = getline(a:lnum)
        let new_line= substitute(line, '\[.\] ', '\[*\] ', '')
        call setline(a:lnum, new_line)
    endfunction

    function! BanJournal_CopyTaskAtLineToDoing(lnum)
        let task_item = getline(a:lnum)
        let task_section_heading = substitute(task_item, '^- \[.\]', '##', '')

        let doing_section_lnum = search('^# DOING', 'n')
        call append(doing_section_lnum, ['', task_section_heading, ''])
    endfunction

    function! BanJournal_AddTimestampNoteWhenStartingTaskAtLine(lnum)
        let task_code = BanJournal_GetTaskCodeForLine(a:lnum)
        let task_lines = BanJournal_GetTaskSectionInterval(task_code)
        let timestamp_lnum = task_lines[0] + 2
        call BanJournal_AddTimestampNoteToLine(timestamp_lnum)
    endfunction

    function! BanJournal_MoveTaskToDone(task_code)
        let initial_line = line('.')
        let start_of_done_section = search('^# DONE', 'nw')
        let task_lines = BanJournal_GetTaskSectionInterval(a:task_code)

        if task_lines[0] > start_of_done_section
            " for some reason, the task is already in DONE
            return
        endif

        execute task_lines[0] .','. task_lines[1] .'move '. (start_of_done_section + 1)
        call cursor(initial_line, 1)
    endfunction

    function! BanJournal_AddEndDateToTaskTitle(task_code)
        " Add note in task about when finished it doing: #end:YYYY-MM-DD
        let template = ' #end:{today}'

        let start_of_done_section = search('^# DONE', 'nw')
        let task_lines = BanJournal_GetTaskSectionInterval(a:task_code)

        if task_lines[0] < start_of_done_section
            " for some reason, the task is not in DONE
            return
        endif

        let note = template
        let note = substitute(note, '{today}', strftime('%Y-%m-%d'), '')
        let title_with_note = substitute(getline(task_lines[0]), '\()\)$', note.'\1', '')
        call setline(task_lines[0], title_with_note)
    endfunction

    function! BanJournal_AddTimestampNoteWhenFinishingTask(task_code)
        let task_lines = BanJournal_GetTaskSectionInterval(a:task_code)
        call append(task_lines[1], ['', '', '', ''])
        call BanJournal_AddTimestampNoteToLine(task_lines[1] + 2, '#end')
    endfunction

    function! BanJournal_GetTaskSectionInterval(task_code)
        let initial_lnum = line('.')

        let task_first_line = search('^## '. a:task_code, 'nw')
        call cursor(task_first_line, 1)

        let start_of_next_section = search('^##\? ', 'nW')
        if start_of_next_section == 0
            call cursor(line('$'), 1000)
        else
            call cursor(start_of_next_section, 1)
        endif

        let task_last_line = search('^.', 'bnW')
        call cursor(initial_lnum, 1)

        return [task_first_line, task_last_line]
    endfunction


    " Legacy journal file behaviour
    " -----------------------------

    autocmd BufReadPost *journal.md if ! exists("g:PROJECT") | let g:PROJECT='eu' | endif
    autocmd BufReadPost *journal.md nmap <buffer> <localleader>P :let g:PROJECT=
    autocmd BufReadPost *journal.md nmap <buffer> <localleader>PP m`:execute ':?^# ?,$s/<project>/' .g:PROJECT. '/g'<CR>``

    " start a new day in journal
    autocmd BufReadPost *journal.md imap <buffer> <localleader>d <Esc>{}"_dG3oa# =strftime("%F %a")2o:let g:PROJECT='timesheet'<CR>a\it <project> timesheet[1]-\te[1]-o:let g:PROJECT='mydaily'<CR>a\it [1[1jzcG:redraw<CR>a\tm \P 

    " create a task item with random task code prefixed with g:PROJECT
    autocmd BufReadPost *journal.md imap <buffer> <localleader>it - [ ] <Esc>:let _='_'. g:PROJECT .'_'. strcharpart(sha256(strftime('%c')),0,7) .'_'<CR>a=_

    " jump to other definitions of the same task item using the location list
    autocmd BufReadPost *journal.md nmap <buffer> gd :let _=expand('<cword>')<CR>:execute 'lvimgrep' '"- \[.\] ' ._. '" %'<CR>

    " create a time-marked note and navigate them
    autocmd BufReadPost *journal.md nmap <silent> <buffer> ]t :call search('^\d\d\d\d-\d\d-\d\d \w\w\w \d\?\d:\d\d')<CR>
    autocmd BufReadPost *journal.md nmap <silent> <buffer> [t :call search('^\d\d\d\d-\d\d-\d\d \w\w\w \d\?\d:\d\d', 'b')<CR>

    " start executing a task from the task item definition
    autocmd BufReadPost *journal.md nmap <buffer> <localleader>te :let _saved_yank_register=@0<CR>\*"0yy]z4o{}j"_d]z"0p0"_df]\2:call search('^# \zs\d\d\d\d-\d\d-\d\d ', 'sb')<CR>"0y$`'0A (0):let @0=_saved_yank_register<CR>A
augroup END


augroup aug_quickscope_colors
    autocmd!
    autocmd ColorScheme * highlight QuickScopePrimary guifg=Cyan gui=underline,bold ctermfg=Cyan cterm=underline
    autocmd ColorScheme * highlight QuickScopeSecondary guifg=Magenta gui=underline,bold ctermfg=Magenta cterm=underline
augroup END


" ==================================================
" Options
" ==================================================

" elements of interface
set number
set scrolloff=0
set lazyredraw

set list listchars=tab:››,trail:·,nbsp:·,extends:→,precedes:←
set cpoptions+=n showbreak=→\ 

set wildmode=list:longest,full

set ttymouse=xterm2  | " enable resizing windows with the mouse

" syntax and colors
syntax reset
if filereadable(expandcmd('~/.vim_colorscheme'))
    execute 'source ~/.vim_colorscheme'
endif

if exists('+termguicolors')
  " truecolor under tmux
  let &t_8f = "\<Esc>[38;2;%lu;%lu;%lum"
  let &t_8b = "\<Esc>[48;2;%lu;%lu;%lum"
endif
set termguicolors

" sane editing
set expandtab tabstop=4 softtabstop=4 shiftwidth=0 | " <TAB> is 4 spaces, once for all!
set ignorecase smartcase
set foldenable foldmethod=indent foldlevel=1
let g:markdown_folding = 1 | " enable folded headings in markdown files

" other options
set hidden
set grepprg=ack\ --nogroup\ $* | " ack is better than grep
set modeline


" ==================================================
" Global mappings
" ==================================================

" Show highlight group of word under cursor
map <leader>0 :echo 'hi<' . synIDattr(synID(line('.'),col('.'),1),'name') . '> trans<'
    \ . synIDattr(synID(line('.'),col('.'),0),'name') . '> lo<'
    \ . synIDattr(synIDtrans(synID(line('.'),col('.'),1)),'name') . '>'<CR>
map <leader>9 :call BanChangeColorscheme()<CR>

map <leader>1 :NERDTreeToggle<CR>
map <leader>2 :FZF<CR>
map <leader>3 :Buffers<CR>
map <leader>4 :TagbarToggle<CR>

nmap <leader>< <plug>(QuickScopeToggle)
xmap <leader>< <plug>(QuickScopeToggle)

" editing
nmap <leader>d :call DuplicateLine("normal")<CR>
vmap <leader>d :<C-U>call DuplicateLine("visual")<CR>
function! DuplicateLine(mode)
    if a:mode == "normal"
        let _pos = col('.')
        copy .
        execute 'normal ' ._pos. '|'
    elseif a:mode == "visual"
        '<,'>copy '>
        normal '>j
    endif
endfunction

nmap <leader>c :call DuplicateAndCommentLine("normal")<CR>
vmap <leader>c :<C-U>call DuplicateAndCommentLine("visual")<CR>
function! DuplicateAndCommentLine(mode)
    if a:mode == "normal"
        let _pos = col('.')
        copy .
        normal k
        .Commentary
        normal j
        execute 'normal ' ._pos. '|'
    elseif a:mode == "visual"
        '<,'>copy '>
        normal gv
        '<,'>Commentary
        execute "normal \<Esc>"
        normal '>j
    endif
endfunction

nmap <leader>s :call IsolateLineWithSpacesAround("normal")<CR>
vmap <leader>s :<C-U>call IsolateLineWithSpacesAround("visual")<CR>
function! IsolateLineWithSpacesAround(mode)
    if a:mode == "normal"
        call append(line(".")-1, [""])
        call append(".", [""])
    elseif a:mode == "visual"
        call append(line("'<")-1, [""])
        call append("'>", [""])
        normal gv
    endif
endfunction

nmap <C-j> :call MoveLine("normal", "down")<CR>
vmap <C-j> :<C-U>call MoveLine("visual", "down")<CR>
nmap <C-k> :call MoveLine("normal", "up")<CR>
vmap <C-k> :<C-U>call MoveLine("visual", "up")<CR>
function! MoveLine(mode, direction)
    let offset = #{down:"+1", up:"-2"}
    if a:mode == "normal"
        execute 'move .' .offset[a:direction]
    elseif a:mode == "visual"
        let target = #{down:"'>", up:"'<"}
        execute "'<,'>move " .target[a:direction] .offset[a:direction]
        normal gv
    endif
endfunction

" file and buffer
map <leader>w :update<CR>
map <leader>fd :saveas! %:p.copy<CR>| " duplicate current file
noremap <silent> <buffer> == :update<CR>gg=G

" navigation
noremap <Space> <C-F>
noremap ]q :cnext<CR>
noremap [q :cprevious<CR>
noremap ]l :lnext<CR>
noremap [l :lprevious<CR>
noremap ]a :next<CR>
noremap [a :previous<CR>

" clipboard
if !has('clipboard') && executable('clip.exe')
    " Use Windows clipboard under WSL
    vnoremap <leader>y "sy:call system('clip.exe', @s)<CR>
else
    vnoremap <leader>y "+y
endif

" git
map g1 :Git<CR>
map gA :Gwrite<CR>:echo 'File staged'<CR>|" git add
map gCC :Git commit -v <CR>
map gCA :Git commit -v --amend <CR>
map g= :Git diff % <CR><C-W>_
map gl :Git --paginate l -50<CR><C-W>_

" toggle options
map <leader>oi :setlocal wrap wrapscan nohlsearch cursorline nocursorcolumn number norelativenumber<CR>
map <leader>od :windo setlocal wrap wrapscan nohlsearch nocursorline nocursorcolumn nonumber relativenumber<CR>p
map <leader>oh :set hlsearch!<CR>:set hlsearch?<CR>
map <leader>ol :setlocal cursorline!<CR>
map <leader>o+ :setlocal cursorcolumn!<CR>
map <leader>on :setlocal number!<CR>
map <leader>op :set paste!<CR>:set paste?<CR>
map <leader>or :setlocal relativenumber!<CR>
map <leader>ow :setlocal wrap!<CR>:set wrap?<CR>

set wrap wrapscan nohlsearch cursorline nocursorcolumn number norelativenumber
