" leader keys
let mapleader=','
let maplocalleader='\'

" Start with vim defaults
if filereadable(expand("$VIMRUNTIME/defaults.vim"))
    unlet! skip_defaults_vim
    source $VIMRUNTIME/defaults.vim
endif


" ==================================================
" Plugins
" ==================================================
" install vim-plug:
" curl -fLo ~/.vim/autoload/plug.vim --create-dirs \
"    https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim

call plug#begin('~/.vim/bundle')

" 1. Must have plugins (in order of importance for me)
" ====================================================

" File system explorer
Plug 'scrooloose/nerdtree'
let NERDTreeIgnore=['__pycache__[[dir]]']
let NERDTreeHijackNetrw = 0

" Fuzzy finder
Plug 'junegunn/fzf', {'dir': '~/.vim/bundle/fzf', 'do': './install --all'}
Plug 'junegunn/fzf.vim'

" Up to date syntax files
Plug 'viniciusban/vim-polyglot'

" Python autocompletion
" The goto_command is a killer feature.
Plug 'davidhalter/jedi-vim'
let g:jedi#popup_on_dot=0
let g:jedi#show_call_signatures_delay=100
let g:jedi#use_splits_not_buffers='winwidth'
let g:jedi#goto_command = '<localleader>D'
let g:jedi#goto_assignments_command = ''
let g:jedi#goto_stubs_command = ''
let g:jedi#rename_command = '<localleader>r'
let g:jedi#usages_command = '<localleader>n'

" My discreet color schemes
Plug 'viniciusban/vim-simple-onblack-colorschemes'


" 2. Good to have plugins
" =======================

" Git inside vim
Plug 'tpope/vim-fugitive'

" Comment lines.
" gcc, gc<motion>, {Visual}gc
Plug 'tpope/vim-commentary'  | " gcc, gc<motion>, {Visual}gc

" My mappings for markdown
Plug 'viniciusban/vim-ft-markdown'


" 3. Nice to have plugins
" =======================

" Add delimiters to text.
" sa, sd, sr
Plug 'machakann/vim-sandwich'

" Class outline viewer
Plug 'majutsushi/tagbar'
let g:tagbar_ctags_bin = 'ctags'
let g:tagbar_autofocus = 1
let g:tagbar_position = 'leftabove vertical'
let g:tagbar_case_insensitive = 1

" Quickly navigate to first and second occurrence of char in line
Plug 'unblevable/quick-scope'
let g:qs_enable=0  |" start plugin with highlight disabled

" colorize parentheses
Plug 'luochen1990/rainbow'
let g:rainbow_active = 0

" Expand abbreviations
Plug 'mattn/emmet-vim'
let g:user_emmet_leader_key = '<C-\>'

" Snippets
Plug 'SirVer/ultisnips'
Plug 'honza/vim-snippets'
let g:UltiSnipsSnippetDirectories=[$HOME.'/src/vim-snippets']

" Replace existing text with the contents of a register
" <register>gr{motion}, {Visual}<register>gr
" Plug 'inkarkat/vim-ReplaceWithRegister'

" Match keywords.
" %, g%, a%, i%, and more
" Plug 'andymass/vim-matchup'  | " %, g%, a%, i%, and more

" required by other text object plugins
" Plug 'kana/vim-textobj-user'

" Select similarly indented lines
" ai, ii
" Plug 'kana/vim-textobj-indent'

" Text objects to select comments
"  ac, ic (remapped below)
" Plug 'glts/vim-textobj-comment'
" omap aC <Plug>(textobj-comment-a)
" xmap aC <Plug>(textobj-comment-a)
" omap iC <Plug>(textobj-comment-i)
" xmap iC <Plug>(textobj-comment-i)

" Text objects for Python functions and classes
" ac, ic, af, if
" Plug 'bps/vim-textobj-python' | " ac, ic, af, if.
" let g:is_pythonsense_suppress_object_keymaps = 1
" let g:is_pythonsense_suppress_motion_keymaps = 1

" Text objects for Python docstrings
" ad, id
" See https://github.com/viniciusban/myconfigs/issues/1
" Plug 'jeetsukumaran/vim-pythonsense'

call plug#end()


" ==================================================
" my own functions
" ==================================================

function! Ban_Run(command)
    " Run an external command using internal or external terminal

    if !exists('g:ban_run_internal')
        if has('gui_running')
            let g:ban_run_internal = 1
        elseif has('nvim')
            let g:ban_run_internal = 1
        else
            let g:ban_run_internal = 0
        endif
    endif

    let quote = "'"
    if g:ban_run_internal == 1
        if has('nvim')
            let prefix = 'tabnew | terminal '. &shell .' -c ' . quote
            let suffix = quote
        else
            let prefix = 'tabnew | terminal ++curwin ++shell '
            let suffix = ''
        endif
        let command = substitute(a:command, quote, "'\"\\'\"'", 'g')
        let command = substitute(command, '#', '\\#', 'g')
    else
        let prefix = '!'
        let command = a:command
        let suffix = ''
    endif

    return prefix . command . suffix
endfunction

function! BanPython_GetCurrentPythonClassName()
    execute "normal ms$?^class \<Enter>0w"
    nohls
    let class_name = expand('<cword>')
    execute 'normal g`s'
    return l:class_name
endfunction

function! BanPython_GetCurrentPythonMethodName()
    execute 'normal ms$?^ \+\(def\|async def\) \+test\w\+(\_s\{-}self?e' . "\<Enter>" . '3b'
    nohls
    let method_name = expand('<cword>')
    execute 'normal g`s'
    return l:method_name
endfunction

function! BanPython_GetCurrentPythonFunctionName()
    execute 'normal ms$?^\(def\|async def\) \+test\w\+(?e' . "\<Enter>" . 'b'
    nohls
    let function_name = expand('<cword>')
    execute 'normal g`s'
    return l:function_name
endfunction

function! BanPython_MakeValidPythonTestName()
    " Transform a phrase into a test method name.
    "
    " Transform this:
    "   show user name
    " Into this:
    "   def test_show_user_name(self):
    "
    let x=getline('.')
    let x=substitute(x, '\(\w\) ', '\1_', 'ge')
    let x=substitute(x, '-', '_', 'ge')
    let x=substitute(x, '\(\S\+\)', 'def test_\1(self):', '')
    call setline('.', x)
endfunction

function! BanPython_GetTestSeparators(command)
    if a:command =~ 'unittest'
        let path_separator = '.'
        let expand_string = '%:.:r'
    elseif a:command =~ '--pyargs'
        let path_separator = '.'
        let expand_string = '%:.:r'
    elseif a:command =~ 'manage.py test'
        let path_separator = '.'
        let expand_string = '%:.:r'
    else
        let path_separator = '/'
        let expand_string = '%:.'
    endif

    if a:command =~ 'pytest'
        let class_separator = '::'
    else
        let class_separator = '.'
    endif

    return [path_separator, class_separator, expand_string]
endfunction

function! BanPython_SetAllSuiteAsTestTarget()
    let g:test_target = ''
endfunction

function! BanPython_SetCurrentPackageAsTestTarget(command)
    let [path_sep, _, _] = BanPython_GetTestSeparators(a:command)
    let g:test_target = substitute(expand('%:.:h'), '/', path_sep, 'g')
endfunction

function! BanPython_SetCurrentModuleAsTestTarget(command)
    let [path_sep, _, expand_arg] = BanPython_GetTestSeparators(a:command)
    let g:test_target = substitute(expand(expand_arg), '/', path_sep, 'g')
endfunction

function! BanPython_SetCurrentClassAsTestTarget(command)
    let [path_sep, class_sep, expand_arg] = BanPython_GetTestSeparators(a:command)
    let target = expand(expand_arg) . class_sep . BanPython_GetCurrentPythonClassName()
    let g:test_target = substitute(target, '/', path_sep, 'g')
endfunction

function! BanPython_SetCurrentMethodAsTestTarget(command)
    let [path_sep, class_sep, expand_arg] = BanPython_GetTestSeparators(a:command)
    let target = expand(expand_arg) . class_sep . BanPython_GetCurrentPythonClassName() . class_sep . BanPython_GetCurrentPythonMethodName()
    let g:test_target = substitute(target, '/', path_sep, 'g')
endfunction

function! BanPython_SetCurrentFunctionAsTestTarget(command)
    let [path_sep, class_sep, expand_arg] = BanPython_GetTestSeparators(a:command)
    let target = expand(expand_arg) . class_sep . BanPython_GetCurrentPythonFunctionName()
    let g:test_target = substitute(target, '/', path_sep, 'g')
endfunction

function! BanPython_RunCurrentTestMethod(command)
    call BanPython_SetCurrentMethodAsTestTarget(a:command)
    let test_command = BanPython_BuildTestCommand(a:command, g:test_target)
    execute Ban_Run('run-test '. test_command)
endfunction

function! BanPython_RunCurrentTestFunction(command)
    call BanPython_SetCurrentFunctionAsTestTarget(a:command)
    let test_command = BanPython_BuildTestCommand(a:command, g:test_target)
    execute Ban_Run('run-test '. test_command)
endfunction

function! BanPython_RunCurrentTestCase(command)
    call BanPython_SetCurrentClassAsTestTarget(a:command)
    let test_command = BanPython_BuildTestCommand(a:command, g:test_target)
    execute Ban_Run('run-test '. test_command)
endfunction

function! BanPython_RunCurrentTestModule(command)
    call BanPython_SetCurrentModuleAsTestTarget(a:command)
    let test_command = BanPython_BuildTestCommand(a:command, g:test_target)
    execute Ban_Run('run-test '. test_command)
endfunction

function! BanPython_RunCurrentTestPackage(command)
    call BanPython_SetCurrentPackageAsTestTarget(a:command)
    let test_command = BanPython_BuildTestCommand(a:command, g:test_target)
    execute Ban_Run('run-test '. test_command)
endfunction

function! BanPython_RunAllTestSuite(command)
    call BanPython_SetAllSuiteAsTestTarget()
    let test_command = BanPython_BuildTestCommand(a:command, '')
    execute Ban_Run('run-test '. test_command)
endfunction

function! BanPython_BuildTestCommand(command, target)
    " The {{ target }} part is used mainly with 'make test'.
    " As you know we can't pass arguments to 'make' as we do to shell scripts.
    " The easiest way is setting an environment variable and call 'make'.
    " So, we use the 'var=value command' syntax.
    "
    " Let's see an example.
    "
    " command: target='--pyargs {{ target }}' make test
    " target: some.package.module::Class::test_method
    "
    " Becomes
    "
    " target='--pyargs some.package.module::Class::test_method' make test
    "

    if a:command =~ '{{ target }}'
        let x = substitute(a:command, '{{ target }}', a:target, 'g')
        return 'eval "'. x .'"'
    endif
    return a:command .' '. a:target
endfunction

function! BanPython_TransformSelectedTextIntoFilename()
    let unnamed_register = @"
    execute 'normal gvy'
    let selected_text = @"
    let @" = unnamed_register
    let filename = substitute(selected_text, '\.', '/', 'ge') .'.py'
    return filename
endfunction

function! BanChangeColorscheme()
    let colors = ["amber_simple_onblack", "brown_simple_onblack", "green_simple_onblack", "red_simple_onblack", "white_simple_onblack"]
    let next_color = get(colors, index(colors, g:colors_name) + 1, colors[0])
    execute "colorscheme " . next_color
endfunction


" ==================================================
" Autocommands
" ==================================================

augroup aug_terminal_mode
    au!
    silent! autocmd TerminalWinOpen * setlocal nonumber norelativenumber
    silent! autocmd TerminalOpen * setlocal nonumber norelativenumber
augroup END

augroup aug_ft_css
    au!
    autocmd FileType css setlocal tabstop=2
augroup END

augroup aug_ft_html
    au!
    autocmd FileType html,htmldjango setlocal tabstop=2
    autocmd FileType html,htmldjango let b:match_words = '<:>,{{:}},{%:%},{:},[:],(:),<!--:-->' .
        \ ',<\@<=\([^/][^ \t>]*\)[^>]*\%(>\|$\):<\@<=/\1>' .
        \ ',{% block:{% endblock,{% if:{% endif,{% for:{% endfor,{% macro:{% endmacro' .
        \ ',{% call:{% endcall,{% filter:{% endfilter,{% set:{% endset'
augroup END

augroup aug_ft_json
    au!
    autocmd FileType json setlocal tabstop=2
augroup END

augroup aug_ft_php
    au!
    autocmd FileType php setlocal foldmethod=marker foldmarker={,}
augroup END

augroup aug_ft_python
    au!
    autocmd FileType python call FtPython()
augroup END

function! FtPython()
    setlocal foldmethod=indent

    " set makeprg option
    let b:default_makeprg = ''
    let b:_makeprg = b:default_makeprg
    if exists('$VIM_MAKEPRG')
        if $VIM_MAKEPRG == 'default'
            let b:_makeprg = b:default_makeprg
        else
            let b:_makeprg = $VIM_MAKEPRG
        endif
    elseif filereadable('Makefile')
        let b:_makeprg = 'TARGET=%\ make\ --no-print-directory\ --silent'
    elseif executable('flake8')
        let b:_makeprg = 'flake8'
    elseif executable('pylint')
        let b:_makeprg = 'pylint'
    endif
    execute 'setlocal makeprg='.b:_makeprg
    unlet b:_makeprg

    " set equalprg option
    let b:default_equalprg = '~/.local/bin/python-style'
    let b:_equalprg = b:default_equalprg
    if exists('$VIM_EQUALPRG')
        if $VIM_EQUALPRG == 'default'
            let b:_equalprg = b:default_equalprg
        else
            let b:_equalprg = $VIM_EQUALPRG
        endif
    elseif filereadable('Makefile')
        let b:_equalprg = 'make\ --no-print-directory\ --silent\ pep8'
    endif
    execute 'setlocal equalprg='.b:_equalprg
    unlet b:_equalprg

    nnoremap <buffer> <localleader>= :update<CR><Esc>gg=G
    nnoremap <buffer> <localleader>m :update<CR>:make %<CR>

    " Mappings for classes, functions and docstrings text-objects
    xnoremap <buffer> ic <Plug>(textobj-python-class-i)
    onoremap <buffer> ic <Plug>(textobj-python-class-i)
    xnoremap <buffer> ac <Plug>(textobj-python-class-a)
    onoremap <buffer> ac <Plug>(textobj-python-class-a)
    xnoremap <buffer> if <Plug>(textobj-python-function-i)
    onoremap <buffer> if <Plug>(textobj-python-function-i)
    xnoremap <buffer> af <Plug>(textobj-python-function-a)
    onoremap <buffer> af <Plug>(textobj-python-function-a)
    xnoremap <buffer> ad <Plug>(PythonsenseOuterDocStringTextObject)
    onoremap <buffer> ad <Plug>(PythonsenseOuterDocStringTextObject)
    xnoremap <buffer> id <Plug>(PythonsenseInnerDocStringTextObject)
    onoremap <buffer> id <Plug>(PythonsenseInnerDocStringTextObject)

    " edit selected module name
    xnoremap <localleader>f :<C-U>let @g = BanPython_TransformSelectedTextIntoFilename() <CR>

    " Mappings to help with tests (this is a big section).
    " All mappings are prefixed with \t.
    if !exists('g:test_command')
        let g:test_command=''
        if $VIM_TEST_COMMAND != ''
            let g:test_command = $VIM_TEST_COMMAND
        else
            if executable('pytest')
                " makes pytest the default test runner if it is present
                let g:test_command = 'pytest --pyargs'
            endif
        endif
    endif
    if !exists('g:test_target')
        let g:test_target = ''
    endif

    " \tt run tests in current vim session.
    " \TT run tests in tmux next pane.
    nnoremap <localleader>tt :wall <CR>:execute Ban_Run('run-test '. BanPython_BuildTestCommand(g:test_command, g:test_target))<CR>
    nnoremap <silent> <localleader>TT :update<CR>:execute '!tmux send-keys -t .+ -l "' .g:test_command. ' ' .g:test_target. '"'<CR>:execute '!tmux send-keys -t .+ Enter'<CR><CR>

    " t<CR> run tests in current vim session.
    " T<CR> run tests in tmux next pane.
    nnoremap t<CR> :wall <CR>:execute Ban_Run('run-test '. BanPython_BuildTestCommand(g:test_command, g:test_target))<CR>
    nnoremap <silent> T<CR> :update<CR>:execute '!tmux send-keys -t .+ -l "' .g:test_command. ' ' .g:test_target. '"'<CR>:execute '!tmux send-keys -t .+ Enter'<CR><CR>

    " \tC configure the test command (along with its arguments).
    " Examples:
    "   - pytest --pyargs
    "   - python manage.py test -v 2
    "   - python -m unittest
    nnoremap <localleader>tC :let g:test_command='<c-r>=g:test_command<cr>'

    " \tn Make a test name from current line contents
    nnoremap <buffer> <localleader>tn :call BanPython_MakeValidPythonTestName() <CR>

    " Mark the target and run tests
    nnoremap <buffer> <localleader>ta :wall <CR>:call BanPython_RunAllTestSuite(g:test_command) <CR>
    nnoremap <buffer> <localleader>tp :wall <CR>:call BanPython_RunCurrentTestPackage(g:test_command) <CR>
    nnoremap <buffer> <localleader>t% :wall <CR>:call BanPython_RunCurrentTestModule(g:test_command) <CR>
    nnoremap <buffer> <localleader>tc :wall <CR>:call BanPython_RunCurrentTestCase(g:test_command) <CR>
    nnoremap <buffer> <localleader>tm :wall <CR>:call BanPython_RunCurrentTestMethod(g:test_command) <CR>
    nnoremap <buffer> <localleader>tf :wall <CR>:call BanPython_RunCurrentTestFunction(g:test_command) <CR>

    " Only mark the target
    nnoremap <buffer> <localleader>TA :wall <CR>:call BanPython_SetAllSuiteAsTestTarget() <CR>:echo g:test_target. ' set as test target.'<CR>
    nnoremap <buffer> <localleader>TP :wall <CR>:call BanPython_SetCurrentPackageAsTestTarget(g:test_command) <CR>:echo g:test_target. ' set as test target.'<CR>
    nnoremap <buffer> <localleader>T% :wall <CR>:call BanPython_SetCurrentModuleAsTestTarget(g:test_command) <CR>:echo g:test_target. ' set as test target.'<CR>
    nnoremap <buffer> <localleader>TC :wall <CR>:call BanPython_SetCurrentClassAsTestTarget(g:test_command) <CR>:echo g:test_target. ' set as test target.'<CR>
    nnoremap <buffer> <localleader>TM :wall <CR>:call BanPython_SetCurrentMethodAsTestTarget(g:test_command) <CR>:echo g:test_target. ' set as test target.'<CR>
    nnoremap <buffer> <localleader>TF :wall <CR>:call BanPython_SetCurrentFunctionAsTestTarget(g:test_command) <CR>:echo g:test_target. ' set as test target.'<CR>

    " copy current filename and function/method to register z in pytest format (JOE specific)
    nnoremap <silent> <localleader>tr :let cursorpos = getcurpos() <CR>:call search('def test', 'besc') <CR>:execute 'normal bye' <CR>:let @z = substitute(expand('%'), '.*joe/tests/', '', '').'::'.getreg('"') <CR>:call setpos('.', cursorpos) <CR>:let test_cmd = "t " .trim(getreg('z'))<CR>:execute '!tmux send-keys -t JOE:src.1 -l "' .test_cmd. '"'<CR>:execute '!tmux send-keys -t JOE:src.1 Enter'<CR><CR>

    syn keyword pythonTodo          TODO FIXME NOTE contained
    hi! link pythonBuiltin Statement
    hi! link pythonDocTest2 Comment
endfunction

augroup aug_ft_make
    au!
    autocmd FileType make setlocal noexpandtab
augroup END

augroup aug_ft_fugitive
    au!
    autocmd FileType fugitive setlocal cursorline
augroup END

augroup aug_ft_gitcommit
    au!
    autocmd FileType gitcommit setlocal foldenable foldmethod=syntax
    autocmd BufRead COMMIT_EDITMSG setlocal nocursorline
    autocmd BufRead COMMIT_EDITMSG call execute(['normal gg'])
    " go to next/prev file in commit
    autocmd FileType gitcommit nnoremap <silent> <buffer> ]] :call search('^diff\\|^# On branch', "z")<CR>ztzv
    autocmd FileType gitcommit nnoremap <silent> <buffer> [[ :call search('^diff\\|^# On branch', "b")<CR>ztzv
    " go to next/prev change
    autocmd FileType gitcommit nnoremap <silent> <buffer> ]c :call search('^@@', "z")<CR>zt
    autocmd FileType gitcommit nnoremap <silent> <buffer> [c :call search('^@@', "b")<CR>zt
augroup END

augroup aug_list_items
    au!

    " add item
    autocmd FileType markdown,text nnoremap <buffer> <localleader>i o- [ ]
    autocmd FileType markdown,text inoremap <buffer> <localleader>i - [ ]

    " mark item as doing/done
    autocmd FileType markdown,text nnoremap <silent> <buffer> <localleader>* :keeppatterns :s/^\(\s*- \[\).]/\1*]/<CR>
    autocmd FileType markdown,text nnoremap <silent> <buffer> <localleader>x :keeppatterns :s/^\(\s*- \[\).]/\1x]/<CR>

    " go to next/previous list item (any level)
    autocmd FileType markdown,text nnoremap <silent> <buffer> ]- :call search('^\s*- ', "z")<CR>
    autocmd FileType markdown,text nnoremap <silent> <buffer> [- :call search('^\s*- ', "b")<CR>

    " go to next/previous sibling
    autocmd FileType markdown,text nnoremap <silent> <buffer> ]= ^:call search("^". strpart(getline("."), 0, col(".")), "z")<CR>
    autocmd FileType markdown,text nnoremap <silent> <buffer> [= ^:let _pat=strpart(getline("."), 0, col("."))<CR>0:call search("^". _pat, "b")<CR>

    " go to parent
    autocmd FileType markdown,text nnoremap <silent> <buffer> [_ ^:call search('\%<' .col("."). 'c\S', "b")<CR>
augroup END

augroup aug_viniciusban_journal
    au!

    " Journal file v2 behaviour and functions
    " ---------------------------------------

    autocmd BufReadPre  *journal*.md let b:journal_loaded=0
    autocmd BufReadPre  *journal*.md syntax manual
    autocmd BufReadPost *journal*.md setlocal foldmethod=manual
    autocmd CursorHold  *journal*.md
        \  if b:journal_loaded == 0
        \ |    setlocal foldmethod=expr syntax=ON
        \ |    let b:journal_loaded=1
        \ |endif

    " task items
    autocmd BufReadPost *journal*.md inoremap <buffer> <localleader>t  <C-o>:call BanJournal_CreateTask($JOURNAL_PROJECT)<CR>
    autocmd BufReadPost *journal*.md nnoremap <buffer> <localleader>t  :call BanJournal_CreateTask($JOURNAL_PROJECT)<CR>
    autocmd BufReadPost *journal*.md inoremap <buffer> <localleader>T  <C-o>:call BanJournal_CreateTask('<project>')
    autocmd BufReadPost *journal*.md nnoremap <buffer> <localleader>T  :call BanJournal_CreateTask('<project>')
    autocmd BufReadPost *journal*.md nnoremap <buffer> <localleader>*  :call BanJournal_StartCurrentTask()<CR>
    autocmd BufReadPost *journal*.md nnoremap <buffer> <localleader>8  :call BanJournal_StartCurrentTask()<CR>
    autocmd BufReadPost *journal*.md nnoremap <buffer> <localleader>x  :call BanJournal_EndCurrentTask()<CR>
    autocmd BufReadPost *journal*.md inoremap <buffer> <localleader>x  <C-o>:call BanJournal_EndCurrentTask()<CR>
    autocmd BufReadPost *journal*.md nnoremap <buffer> <localleader>.  :call BanJournal_PauseCurrentTask()<CR>
    autocmd BufReadPost *journal*.md inoremap <buffer> <localleader>.  <C-o>:call BanJournal_PauseCurrentTask()<CR>
    autocmd BufReadPost *journal*.md nnoremap <buffer> <localleader>l  :let _=strftime('%Y-%m-%d')<CR>:call BanJournal_ListTasksTouchedOnDate('=_<CR>')

    " timestamp notes
    autocmd BufReadPost *journal*.md inoremap <buffer> <localleader>n  <C-o>:call BanJournal_AddTimestampNoteToCurrentLine()<CR>
    autocmd BufReadPost *journal*.md nnoremap <buffer> <localleader>n  :call BanJournal_AddTimestampNoteToCurrentLine()<CR>
    autocmd BufReadPost *journal*.md inoremap <buffer> <localleader>N  <C-o>:call BanJournal_AddTimestampNoteToCurrentLine('-', 'without_task_code')<CR>
    autocmd BufReadPost *journal*.md nnoremap <buffer> <localleader>N  :call BanJournal_AddTimestampNoteToCurrentLine('-', 'without_task_code')<CR>
    autocmd BufReadPost *journal*.md nnoremap <silent> <buffer> ]n :call search('^\d\d\d\d-\d\d-\d\d \w\w\w \d\?\d:\d\d')<CR>
    autocmd BufReadPost *journal*.md nnoremap <silent> <buffer> [n :call search('^\d\d\d\d-\d\d-\d\d \w\w\w \d\?\d:\d\d', 'b')<CR>

    " daily records
    autocmd BufReadPost *journal*.md inoremap <buffer> <localleader>d  <C-o>:call BanJournal_StartANewDay($JOURNAL_PROJECT)<CR><Esc>A
    autocmd BufReadPost *journal*.md inoremap <buffer> <localleader>s  <C-o>:call BanJournal_CreateTheTimesheetTaskInCurrentLine('<project>')



    " New journal file support functions
    " ----------------------------------

    function! BanJournal_ShowMappings()
        echom '      New: day \d      timesheet \s'
        echom '    Tasks: create \t   start \*   end \x   pause \.   touched \l'
        echom 'Timestamp: create \n   prev [n    next ]n'
    endfunction

    function! BanJournal_CreateTask(project)
        " Create a task in current line

        let lnum = line('.')
        call BanJournal_DoCreateTask(lnum, a:project, trim(getline(lnum)))
        call cursor(lnum, col('$'))
    endfunction

    function! BanJournal_StartCurrentTask()
        " Create the task section in DOING. Keep it in BACKLOG.

        let lnum = line('.')
        call BanJournal_DoStartTaskAtLine(lnum)
        let task_code = BanJournal_GetTaskCodeForLine(lnum)
        let [_, last_lnum] = BanJournal_GetTaskSectionInterval(task_code)
        call cursor(last_lnum, 1000)
        normal zx
    endfunction

    function! BanJournal_EndCurrentTask()
        let lnum = line('.')
        let task_code = BanJournal_GetTaskCodeForLine(lnum)
        if task_code == ''
            echom 'Error: Not a task'
            return
        endif
        call BanJournal_DoEndTask(task_code)
        normal zv
    endfunction

    function! BanJournal_PauseCurrentTask()
        let lnum = line('.')
        let task_code = BanJournal_GetTaskCodeForLine(lnum)
        if task_code == ''
            echom 'Error: Not a task'
            return
        endif
        call BanJournal_DoPauseTask(task_code)
    endfunction

    function! BanJournal_AddTimestampNoteToCurrentLine(description = '', option = '')
        let lnum = line('.')
        call BanJournal_AddTimestampNoteToLine(lnum, a:description, a:option)
        call cursor(lnum, col('$'))
    endfunction

    function! BanJournal_CreateTheDailyTaskInCurrentLine()
        let lnum = line('.')
        let task_description = 'daily '. strftime('%Y-%m-%d %a')
        let day_of_week = strftime('%a')
        call BanJournal_DoCreateTask(lnum, 'daily', task_description, day_of_week)
        call BanJournal_MarkTaskAtLineAsDoing(lnum)
        call BanJournal_CopyTaskAtLineToDoing(lnum)
        let task_code = BanJournal_GetTaskCodeForLine(lnum)
        let [_, last_lnum] = BanJournal_GetTaskSectionInterval(task_code)
        call append(last_lnum, '')
        call cursor(last_lnum + 2, 1)
    endfunction

    function! BanJournal_CreateTheTimesheetTaskInCurrentLine(project)
        let lnum = line('.')
        let task_description = a:project . ' timesheet '. strftime('%Y-%m-%d %a')
        let task_suffix = 'timesheet_'. strftime('%a')
        call BanJournal_DoCreateTask(lnum, a:project, task_description, task_suffix)
        call BanJournal_MarkTaskAtLineAsDoing(lnum)
        call BanJournal_CopyTaskAtLineToDoing(lnum)
        call BanJournal_AddTimestampNoteWhenStartingTimesheetAtLine(lnum)
        let task_code = BanJournal_GetTaskCodeForLine(lnum)
        let [_, last_lnum] = BanJournal_GetTaskSectionInterval(task_code)
        call append(last_lnum, '')
        call cursor(last_lnum, 1000)
        normal zx
    endfunction

    function! BanJournal_StartANewDay(project)
        let lnum = line('.')
        call BanJournal_CreateTheDailyTaskInCurrentLine()
        call append(lnum, '')
        call cursor(lnum + 1, 1)
        call BanJournal_CreateTheTimesheetTaskInCurrentLine(a:project)
    endfunction

    function! BanJournal_DoCreateTask(lnum, project, description, task_suffix='')
        " Create a task in line `lnum`.
        "
        " Format: _{project}_{date}_{suffix}_

        let template = '- [ ] {task_code} {description}'
        let task_code = BanJournal_BuildTaskCode(a:project, a:task_suffix)
        let new_line = template

        let new_line = substitute(new_line, '{task_code}', task_code, '')
        let new_line = substitute(new_line, '{description}', a:description, '')

        call setline(a:lnum, new_line)
    endfunction

    function! BanJournal_DoStartTaskAtLine(lnum)
        " Start the task at `lnum` line.

        let lnum = line('.')
        call BanJournal_AddStartDateToTaskTitleAtLine(lnum)
        call BanJournal_MarkTaskAtLineAsDoing(lnum)
        call BanJournal_CopyTaskAtLineToDoing(lnum)
        call BanJournal_AddTimestampNoteWhenStartingTaskAtLine(lnum)
        normal zx
    endfunction

    function! BanJournal_DoEndTask(task_code)
        " Remove from BACKLOG. Move from DOING to DONE.

        let task_item_lnum = BanJournal_FindTaskItemWithTaskCode(a:task_code)
        execute task_item_lnum . 'delete _'
        call BanJournal_MoveTaskToDone(a:task_code)
        call BanJournal_AddEndDateToTaskTitle(a:task_code)
        call BanJournal_AddTimestampNoteWhenFinishingTask(a:task_code)
    endfunction

    function! BanJournal_DoPauseTask(task_code)
        " Mark task as paused.

        let task_item_lnum = BanJournal_FindTaskItemWithTaskCode(a:task_code)
        call BanJournal_MarkTaskAtLineAsPaused(task_item_lnum)
        call BanJournal_AddTimestampNoteWhenPausingTask(a:task_code)
    endfunction

    function! BanJournal_AddTimestampNoteToLine(lnum, description = '', ...)
        if count(a:000, 'without_task_code') == 0
            let template = '{today} {weekday} {now} {task_code}{description}'
            let task_code = BanJournal_GetTaskCodeForLine(a:lnum)
        else
            let template = '{today} {weekday} {now}{description}'
            let task_code = ''
        endif
        let new_line = template

        if empty(a:description)
            let description = ''
        else
            let description = ' '. a:description
        endif

        let new_line = substitute(new_line, '{today}', strftime("%Y-%m-%d"), '')
        let new_line = substitute(new_line, '{weekday}', strftime("%a"), '')
        let new_line = substitute(new_line, '{now}', strftime("%H:%M"), '')
        let new_line = substitute(new_line, '{task_code}', task_code, '')
        let new_line = substitute(new_line, '{description}', description, '')

        call setline(a:lnum, new_line)
    endfunction

    function! BanJournal_BuildTaskCode(project, suffix='')
        " Assemble different pieces to build a task code.
        let template = '_{project}_{today}_{suffix}_'
        if a:suffix == ''
            let suffix = BanJournal_CreateRandomCodeWithLength(2)
        else
            let suffix = a:suffix
        endif

        let task_code = template
        let task_code = substitute(task_code, '{project}', a:project, '')
        let task_code = substitute(task_code, '{today}', strftime("%y%m%d"), '')
        let task_code = substitute(task_code, '{suffix}', suffix, '')
        return task_code
    endfunction

    function! BanJournal_CreateRandomCodeWithLength(length)
        " Create a random code with `length` chars.
        let chars = 'abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'
        let len_chars = len(chars)
        let result = []
        for _ in range(a:length)
            let i = rand() % len_chars
            call add(result, chars[i])
        endfor
        return join(result, '')
    endfunction

    function! BanJournal_FindTaskItemWithTaskCode(task_code)
        let item_lnum = search('^- \[.\] '. a:task_code, 'n')
        return item_lnum
    endfunction

    function! BanJournal_GetTaskCodeForLine(lnum)
        let task_code = BanJournal_GetTaskCodeFromItemList(a:lnum)
        if task_code == ''
            let task_code = BanJournal_GetTaskCodeFromInsideTaskSection(a:lnum)
        endif

        return task_code
    endfunction

    function! BanJournal_GetTaskCodeFromItemList(lnum)
        let pattern = '^- \[.\] \(_\w\+_\)\W'
        let matches = matchlist(getline(a:lnum), pattern)
        if empty(matches)
            return ''
        endif
        return matches[1]
    endfunction

    function! BanJournal_GetTaskCodeFromInsideTaskSection(lnum)
        " Task codes are in level 2 heading
        let pattern = '^## \(_\w\+_\)\W'
        let initial_lnum = line('.')

        call cursor(a:lnum, 1)
        let task_first_lnum = search(pattern, 'bcnW')
        call cursor(initial_lnum, 1)

        if task_first_lnum == 0
            return ''
        endif

        let matches = matchlist(getline(task_first_lnum), pattern)
        if empty(matches)
            return ''
        endif
        return matches[1]
    endfunction

    function! BanJournal_AddStartDateToTaskTitleAtLine(lnum)
        " Add note in task about when started doing: (#start:YYYY-MM-DD)
        let line_template = '{previous_contents} {note}'
        let note_template = '(#start:{today})'

        let note = note_template
        let note = substitute(note, '{today}', strftime('%Y-%m-%d'), '')

        let new_line = line_template
        let new_line = substitute(new_line, '{previous_contents}', getline(a:lnum), '')
        let new_line = substitute(new_line, '{note}', note, '')

        call setline(a:lnum, new_line)
    endfunction

    function! BanJournal_MarkTaskAtLineAsDoing(lnum)
        let contents = getline(a:lnum)
        let new_line= substitute(contents, '\[.\] ', '\[*\] ', '')
        call setline(a:lnum, new_line)
    endfunction

    function! BanJournal_MarkTaskAtLineAsPaused(lnum)
        let contents = getline(a:lnum)
        let new_line= substitute(contents, '\[.\] ', '\[.\] ', '')
        call setline(a:lnum, new_line)
    endfunction

    function! BanJournal_CopyTaskAtLineToDoing(lnum)
        let task_item = getline(a:lnum)
        let task_section_heading = substitute(task_item, '^- \[.\]', '##', '')

        let doing_section_lnum = search('^# DOING', 'n')
        call append(doing_section_lnum, ['', task_section_heading, ''])
    endfunction

    function! BanJournal_AddTimestampNoteWhenStartingTaskAtLine(lnum)
        let task_code = BanJournal_GetTaskCodeForLine(a:lnum)
        let [first_lnum, _] = BanJournal_GetTaskSectionInterval(task_code)
        let timestamp_lnum = first_lnum + 2
        call BanJournal_AddTimestampNoteToLine(timestamp_lnum)
        call append(timestamp_lnum, ['', ''])
    endfunction

    function! BanJournal_AddTimestampNoteWhenStartingTimesheetAtLine(lnum)
        let task_code = BanJournal_GetTaskCodeForLine(a:lnum)
        let [first_lnum, _] = BanJournal_GetTaskSectionInterval(task_code)
        let timestamp_lnum = first_lnum + 2
        call BanJournal_AddTimestampNoteToLine(timestamp_lnum, '-', 'without_task_code')
    endfunction

    function! BanJournal_MoveTaskToDone(task_code)
        let initial_lnum = line('.')
        let done_section_lnum = search('^# DONE', 'nw')
        let [first_lnum, last_lnum] = BanJournal_GetTaskSectionInterval(a:task_code)

        if first_lnum > done_section_lnum
            " for some reason, the task is already in DONE
            return
        endif

        execute first_lnum .','. last_lnum .'move '. (done_section_lnum + 1)
        call cursor(initial_lnum, 1)
    endfunction

    function! BanJournal_AddEndDateToTaskTitle(task_code)
        " Add note in task about when finished it doing: #end:YYYY-MM-DD
        let template = ' #end:{today}'

        let done_section_lnum = search('^# DONE', 'nw')
        let [first_lnum, _] = BanJournal_GetTaskSectionInterval(a:task_code)

        if first_lnum < done_section_lnum
            " for some reason, the task is not in DONE
            return
        endif

        let note = template
        let note = substitute(note, '{today}', strftime('%Y-%m-%d'), '')
        let title_with_note = substitute(getline(first_lnum), '\()\)$', note.'\1', '')
        call setline(first_lnum, title_with_note)
    endfunction

    function! BanJournal_AddTimestampNoteWhenFinishingTask(task_code)
        let [_, last_lnum] = BanJournal_GetTaskSectionInterval(a:task_code)
        call append(last_lnum, ['', '', '', ''])
        call BanJournal_AddTimestampNoteToLine(last_lnum + 2, '#end')
    endfunction

    function! BanJournal_AddTimestampNoteWhenPausingTask(task_code)
        let [_, last_lnum] = BanJournal_GetTaskSectionInterval(a:task_code)
        let note_lnum = last_lnum + 2
        call append(note_lnum, ['', ''])
        call BanJournal_AddTimestampNoteToLine(note_lnum, '#paused')
        call cursor(note_lnum, 1)
        normal zv
    endfunction

    function! BanJournal_GetTaskSectionInterval(task_code)
        let initial_lnum = line('.')

        let task_first_lnum = search('^## '. a:task_code, 'nw')
        call cursor(task_first_lnum, 1)

        let next_section_lnum = search('^##\? ', 'nW')
        if next_section_lnum == 0
            call cursor(line('$'), 1000)
        else
            call cursor(next_section_lnum, 1)
        endif

        let task_last_lnum = search('^.', 'bnW')
        call cursor(initial_lnum, 1)

        return [task_first_lnum, task_last_lnum]
    endfunction

    function! BanJournal_ListTasksTouchedOnDate(date_arg)
        " Use location list to show all the tasks I have worked on that date.
        let v:errmsg = ''
        silent! execute 'lvimgrep '. a:date_arg . ' '. expand('%')

        if v:errmsg != ''
            echohl ErrorMsg | echom 'Nothing found for ' . a:date_arg | echohl None
            return
        endif

        let tasks_touched = {}

        for item in getloclist(0)
            let [lnum, text] = [item['lnum'], item['text']]

            if match(text, '^- \[.\] ') > -1
                " line is a task item
                let matches = matchlist(text, ' \(_\w\{-\}_\)\>.\(.*\)')
                let task_code = matches[1]
                let description = matches[2]
            elseif match(text, '^## ') > -1
                " line is the start of a task session
                let matches = matchlist(text, ' \(_\w\{-\}_\)\>.\(.*\)')
                let task_code = matches[1]
                let description = matches[2]
            elseif match(text, '^\d\d\d\d-\d\d-\d\d \w\w\w \d\d:\d\d \(_\w\{-\}_\>\)\?\(.*\)') > -1
                " line is a timestamp note
                let notes = ''
                let matches = matchlist(text, '^\d\d\d\d-\d\d-\d\d \w\w\w \d\d:\d\d \(_\w\{-\}_\>\)\?\(.*\)')
                if matches[1] != ''
                    let task_code = matches[1]
                    if matches[2] != ''
                        let notes = trim(matches[2])
                    endif
                else
                    let task_code = BanJournal_GetTaskCodeFromInsideTaskSection(lnum)
                endif

                let [first_lnum, _] = BanJournal_GetTaskSectionInterval(task_code)
                let matches = matchlist(getline(first_lnum), ' _\w\{-\}_\>.\(.*\)')
                let task_description = trim(matches[1])

                " Get subsection title to show in location list
                let initial_lnum = line('.')
                call cursor(lnum, 1)
                let subsection_lnum = search('^#', 'bnW', first_lnum)
                call cursor(initial_lnum, 1)
                if subsection_lnum <= first_lnum
                    let subsection_title = ''
                else
                    let matches = matchlist(getline(subsection_lnum), '^#\+ \(.\+\)')
                    let subsection_title = matches[1]
                endif

                if subsection_title == ''
                    let description = task_description .' | '. notes
                else
                    let description = task_description .' | '. subsection_title .' | '. notes
                endif
            else
                continue
            endif

            if match(task_code, '_daily_\|_timesheet_') > -1
                " ignore daily and timesheet tasks
                continue
            endif

            let tasks_touched[task_code] = {'lnum': lnum, 'text': description, 'task_code': task_code}
        endfor

        let sorted_list = sort(values(tasks_touched), 'BanJournal_SortListOfTasksTouchedOnDateByLnum')
        let new_items = []
        let filename = expand('%')

        for item in sorted_list
            call add(new_items, {
                \ 'filename': filename,
                \ 'module': item['task_code'],
                \ 'lnum': item['lnum'],
                \ 'text': item['text']
                \})
        endfor
        call setloclist(0, [], 'r', {'title': 'Tasks for '. a:date_arg, 'items': new_items})
        lopen
    endfunction

    function! BanJournal_SortListOfTasksTouchedOnDateByLnum(first, second)
        if a:first['lnum'] < a:second['lnum']
            return -1
        endif
        return 1
    endfunction

augroup END


augroup aug_quickscope_colors
    autocmd!
    autocmd ColorScheme * highlight QuickScopePrimary guifg=Cyan gui=underline,bold ctermfg=Cyan cterm=underline
    autocmd ColorScheme * highlight QuickScopeSecondary guifg=Magenta gui=underline,bold ctermfg=Magenta cterm=underline
augroup END


" ==================================================
" Options
" ==================================================

" elements of interface
set number
set scrolloff=0
set lazyredraw

set list listchars=tab:››,trail:·,nbsp:·,extends:→,precedes:←
set cpoptions+=n showbreak=→\ 

set wildmode=list:longest,full

set ttymouse=xterm2  | " enable resizing windows with the mouse

" syntax and colors
syntax reset
if filereadable(expandcmd('~/.vim_colorscheme'))
    execute 'source ~/.vim_colorscheme'
endif

if exists('+termguicolors')
  " truecolor under tmux
  let &t_8f = "\<Esc>[38;2;%lu;%lu;%lum"
  let &t_8b = "\<Esc>[48;2;%lu;%lu;%lum"
endif
set termguicolors

" sane editing
set expandtab tabstop=4 softtabstop=4 shiftwidth=0 | " <TAB> is 4 spaces, once for all!
set ignorecase smartcase
set foldenable foldlevel=1
if !exists('g:loaded_vimrc')
    set foldmethod=indent
endif
let g:markdown_folding = 1 | " enable folded headings in markdown files

" other options
set hidden
set grepprg=ack\ --nogroup\ $* | " ack is better than grep
set modeline


" ==================================================
" Global mappings
" ==================================================

" Show highlight group of word under cursor
nnoremap <leader>0 :echo 'hi<' . synIDattr(synID(line('.'),col('.'),1),'name') . '> trans<'
    \ . synIDattr(synID(line('.'),col('.'),0),'name') . '> lo<'
    \ . synIDattr(synIDtrans(synID(line('.'),col('.'),1)),'name') . '>'<CR>
nnoremap <leader>9 :call BanChangeColorscheme()<CR>

nnoremap <leader>1 :NERDTreeToggle<CR>
nnoremap <leader>2 :FZF<CR>
nnoremap <leader>3 :Buffers<CR>
nnoremap <leader>4 :TagbarToggle<CR>

nnoremap <leader>< <plug>(QuickScopeToggle)
xnoremap <leader>< <plug>(QuickScopeToggle)

" editing
nnoremap <leader>d :call DuplicateLine("normal")<CR>
vnoremap <leader>d :<C-U>call DuplicateLine("visual")<CR>
function! DuplicateLine(mode)
    if a:mode == "normal"
        let _pos = col('.')
        copy .
        execute 'normal ' ._pos. '|'
    elseif a:mode == "visual"
        '<,'>copy '>
        normal '>j
    endif
endfunction

nnoremap <leader>c :call DuplicateAndCommentLine("normal")<CR>
vnoremap <leader>c :<C-U>call DuplicateAndCommentLine("visual")<CR>
function! DuplicateAndCommentLine(mode)
    if a:mode == "normal"
        let _pos = col('.')
        copy .
        normal k
        .Commentary
        normal j
        execute 'normal ' ._pos. '|'
    elseif a:mode == "visual"
        '<,'>copy '>
        normal gv
        '<,'>Commentary
        execute "normal \<Esc>"
        normal '>j
    endif
endfunction

nnoremap <leader>s :call IsolateLineWithSpacesAround("normal")<CR>
vnoremap <leader>s :<C-U>call IsolateLineWithSpacesAround("visual")<CR>
function! IsolateLineWithSpacesAround(mode)
    if a:mode == "normal"
        call append(line(".")-1, [""])
        call append(".", [""])
    elseif a:mode == "visual"
        call append(line("'<")-1, [""])
        call append("'>", [""])
        normal gv
    endif
endfunction

nnoremap <C-j> :call MoveLine("normal", "down")<CR>
vnoremap <C-j> :<C-U>call MoveLine("visual", "down")<CR>
nnoremap <C-k> :call MoveLine("normal", "up")<CR>
vnoremap <C-k> :<C-U>call MoveLine("visual", "up")<CR>
function! MoveLine(mode, direction)
    let offset = #{down:"+1", up:"-2"}
    if a:mode == "normal"
        execute 'move .' .offset[a:direction]
    elseif a:mode == "visual"
        let target = #{down:"'>", up:"'<"}
        execute "'<,'>move " .target[a:direction] .offset[a:direction]
        normal gv
    endif
endfunction

" file and buffer
nnoremap <leader>w :update<CR>
nnoremap <leader>fd :saveas! %:p.copy<CR>| " duplicate current file
nnoremap <silent> <buffer> == :update<CR>gg=G

" navigation
nnoremap <Space> <C-F>
nnoremap ]q :cnext<CR>
nnoremap [q :cprevious<CR>
nnoremap ]l :lnext<CR>
nnoremap [l :lprevious<CR>
nnoremap ]a :next<CR>
nnoremap [a :previous<CR>

" clipboard
if !has('clipboard') && executable('clip.exe')
    " Use Windows clipboard under WSL
    vnoremap <leader>y "sy:call system('clip.exe', @s)<CR>
else
    vnoremap <leader>y "+y
endif

" git
nnoremap gG :Git<CR>
nnoremap gA :Gwrite<CR>:echo 'File staged'<CR>|" git add
nnoremap gC :Git commit -v <CR>
nnoremap g! :Git commit -v --amend <CR>
nnoremap g= :Git diff % <CR><C-W>_
nnoremap gl :Git --paginate l -50<CR><C-W>_

" toggle options
nnoremap <silent> <leader>oe :setlocal wrap wrapscan nohlsearch cursorline nocursorcolumn number norelativenumber<CR>
nnoremap <silent> <leader>od :windo setlocal wrap wrapscan nohlsearch nocursorline nocursorcolumn nonumber relativenumber<CR>p
nnoremap <silent> <leader>oh :set hlsearch!<CR>:set hlsearch?<CR>
nnoremap <silent> <leader>o- :setlocal cursorline!<CR>
nnoremap <silent> <leader>o\ :setlocal cursorcolumn!<CR>
nnoremap <silent> <leader>on :setlocal number!<CR>
nnoremap <silent> <leader>op :set paste!<CR>:set paste?<CR>
nnoremap <silent> <leader>or :setlocal relativenumber!<CR>
nnoremap <silent> <leader>ow :setlocal wrap!<CR>:set wrap?<CR>

normal ,oe
let g:loaded_vimrc=1
