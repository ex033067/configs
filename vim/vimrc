" leader keys
let mapleader=','
let maplocalleader='\'

" Start with vim defaults
if !has('nvim') && filereadable(expand("$VIMRUNTIME/defaults.vim"))
    unlet! skip_defaults_vim
    source $VIMRUNTIME/defaults.vim
endif

" Some plugins need termguicolors beforehand
set termguicolors

" ==================================================
" Plugins
" ==================================================
" install vim-plug:
" curl -fLo ~/.vim/autoload/plug.vim --create-dirs \
"    https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim

call plug#begin('~/.vim/bundle')

" 1. Must have plugins (in order of importance for me)
" ====================================================

" File system explorer
Plug 'scrooloose/nerdtree'
let NERDTreeIgnore=['__pycache__[[dir]]']
let NERDTreeHijackNetrw = 0

" Fuzzy finder
Plug 'junegunn/fzf', {'dir': '~/.vim/bundle/fzf', 'do': './install --all'}
Plug 'junegunn/fzf.vim'

" let g:fzf_colors = {
"     \ 'fg': ['fg', 'Normal'],
"     \ 'bg': ['bg', 'Normal'],
"     \ 'hl': ['bg', 'Search'],
"     \ 'fg+': ['fg', 'customSelectedItem', 'CursorLine', 'Normal'],
"     \ 'bg+': ['bg', 'customSelectedItem', 'CursorLine'],
"     \ 'hl+': ['bg', 'Search'],
"     \ 'info': ['fg', 'Normal'],
"     \ 'border': ['fg', 'Comment'],
"     \ 'prompt': ['fg', 'Normal'],
"     \ 'pointer': ['fg', 'customSelectedItem'],
"     \ 'marker': ['fg', 'Normal'],
"     \ 'spinner': ['fg', 'Normal'],
"     \ 'header': ['fg', 'Normal'] }

" Up to date syntax files
Plug 'viniciusban/vim-polyglot'

" Python autocompletion
" The goto_command is a killer feature.
Plug 'davidhalter/jedi-vim'
let g:jedi#popup_on_dot=0
let g:jedi#show_call_signatures_delay=100
let g:jedi#goto_command = '<localleader>d'
let g:jedi#goto_assignments_command = ''
let g:jedi#goto_stubs_command = ''
let g:jedi#rename_command = '<localleader>r'
let g:jedi#usages_command = '<localleader>n'

" My discreet color scheme
Plug 'viniciusban/vim-white-on-black-colorscheme'


" 2. Good to have plugins
" =======================

" Git inside vim
Plug 'tpope/vim-fugitive'

" Comment lines.
" gcc, gc<motion>, {Visual}gc
Plug 'tpope/vim-commentary'  | " gcc, gc<motion>, {Visual}gc

" My mappings for markdown
Plug 'viniciusban/vim-ft-markdown'

" Run flake8
Plug 'nvie/vim-flake8'


" 3. Nice to have plugins
" =======================

" Add delimiters to text.
" sa, sd, sr
Plug 'machakann/vim-sandwich'

" Class outline viewer
Plug 'majutsushi/tagbar'
let g:tagbar_ctags_bin = 'ctags'
let g:tagbar_autofocus = 1
let g:tagbar_position = 'leftabove vertical'
let g:tagbar_case_insensitive = 1

" Quickly navigate to first and second occurrence of char in line
Plug 'unblevable/quick-scope'
let g:qs_enable=0  |" start plugin with highlight disabled

" colorize parentheses
Plug 'luochen1990/rainbow'
let g:rainbow_active = 1
let _only_to_test_rainbow_colors = trim('1'. trim('2'. trim('3'. trim('4'. trim('5'. trim('6'. trim('7'. trim('8'))))))))
let g:rainbow_conf = {
    \'guifgs': [
        \'#BFBFBF', '#D9534F', '#3399FF', '#00CC66',
        \'#FFB3BA', '#FF00FF', '#00FFFF', '#C02F1D'
    \]
\}

" Expand abbreviations
Plug 'mattn/emmet-vim'
let g:user_emmet_leader_key = '<C-\>'

" Snippets
Plug 'SirVer/ultisnips'
Plug 'honza/vim-snippets'
let g:UltiSnipsSnippetDirectories=[$HOME.'/src/vim-snippets']

" Replace existing text with the contents of a register
" <register>gr{motion}, {Visual}<register>gr
" Plug 'inkarkat/vim-ReplaceWithRegister'

" Match keywords.
" %, g%, a%, i%, and more
" Plug 'andymass/vim-matchup'  | " %, g%, a%, i%, and more

" required by other text object plugins
" Plug 'kana/vim-textobj-user'

" Select similarly indented lines
" ai, ii
" Plug 'kana/vim-textobj-indent'

" Text objects to select comments
"  ac, ic (remapped below)
" Plug 'glts/vim-textobj-comment'
" omap aC <Plug>(textobj-comment-a)
" xmap aC <Plug>(textobj-comment-a)
" omap iC <Plug>(textobj-comment-i)
" xmap iC <Plug>(textobj-comment-i)

" Text objects for Python functions and classes
" ac, ic, af, if
" Plug 'bps/vim-textobj-python' | " ac, ic, af, if.
" let g:is_pythonsense_suppress_object_keymaps = 1
" let g:is_pythonsense_suppress_motion_keymaps = 1

" Text objects for Python docstrings
" ad, id
" See https://github.com/viniciusban/myconfigs/issues/1
" Plug 'jeetsukumaran/vim-pythonsense'

" " Insert or delete brackets, parens, quotes in pair
" Plug 'jiangmiao/auto-pairs'
" let g:AutoPairsShortcutFastWrap = '<leader>pe'
" let g:AutoPairsShortcutToggle = '<leader>pp'
" let g:AutoPairsFlyMode = 1

" Colorize color names and hex codes
if has('nvim')
    Plug 'norcalli/nvim-colorizer.lua'
else
    Plug 'chrisbra/Colorizer'
endif

call plug#end()


" For 'norcalli/nvim-colorizer.lua' plugin
if has('nvim')
    lua require'colorizer'.setup()
endif

" ==================================================
" my own functions
" ==================================================

function! Ban_Run(command)
    " Run an external command using internal or external terminal

    if !exists('g:ban_run_internal')
        if has('gui_running')
            let g:ban_run_internal = 1
        elseif has('nvim')
            let g:ban_run_internal = 1
        else
            let g:ban_run_internal = 0
        endif
    endif

    let quote = "'"
    if g:ban_run_internal == 1
        if has('nvim')
            let prefix = 'tabnew | terminal '. &shell .' -c ' . quote
            let suffix = quote
        else
            let prefix = 'tabnew | terminal ++curwin ++shell '
            let suffix = ''
        endif
        let command = substitute(a:command, quote, "'\"\\'\"'", 'g')
        let command = substitute(command, '#', '\\#', 'g')
    else
        let prefix = '!'
        let command = a:command
        let suffix = ''
    endif

    return prefix . command . suffix
endfunction

function! BanPython_GetCurrentPythonClassName()
    execute "normal ms$?^class \<Enter>0w"
    nohls
    let class_name = expand('<cword>')
    execute 'normal g`s'
    return l:class_name
endfunction

function! BanPython_GetCurrentPythonMethodName()
    execute 'normal ms$?^ \+\(def\|async def\) \+test\w\+(\_s\{-}self?e' . "\<Enter>" . '3b'
    nohls
    let method_name = expand('<cword>')
    execute 'normal g`s'
    return l:method_name
endfunction

function! BanPython_GetCurrentPythonFunctionName()
    execute 'normal ms$?^\(def\|async def\) \+test\w\+(?e' . "\<Enter>" . 'b'
    nohls
    let function_name = expand('<cword>')
    execute 'normal g`s'
    return l:function_name
endfunction

function! BanPython_MakeValidPythonTestName()
    " Transform a phrase into a test method name.
    "
    " Transform this:
    "   show user name
    " Into this:
    "   def test_show_user_name(self):
    "
    let x=getline('.')
    let x=substitute(x, '\(\w\) ', '\1_', 'ge')
    let x=substitute(x, '-', '_', 'ge')
    let x=substitute(x, '\(\S\+\)', 'def test_\1(self):', '')
    call setline('.', x)
endfunction

function! BanPython_GetTestSeparators(command)
    if a:command =~ 'unittest'
        let path_separator = '.'
        let expand_string = '%:.:r'
    elseif a:command =~ '--pyargs'
        let path_separator = '.'
        let expand_string = '%:.:r'
    elseif a:command =~ 'manage.py test'
        let path_separator = '.'
        let expand_string = '%:.:r'
    else
        let path_separator = '/'
        let expand_string = '%:.'
    endif

    if a:command =~ 'pytest'
        let class_separator = '::'
    else
        let class_separator = '.'
    endif

    return [path_separator, class_separator, expand_string]
endfunction

function! BanPython_SetAllSuiteAsTestTarget()
    let g:test_target = ''
endfunction

function! BanPython_SetCurrentPackageAsTestTarget(command)
    let [path_sep, _, _] = BanPython_GetTestSeparators(a:command)
    let g:test_target = substitute(expand('%:.:h'), '/', path_sep, 'g')
endfunction

function! BanPython_SetCurrentModuleAsTestTarget(command)
    let [path_sep, _, expand_arg] = BanPython_GetTestSeparators(a:command)
    let g:test_target = substitute(expand(expand_arg), '/', path_sep, 'g')
endfunction

function! BanPython_SetCurrentClassAsTestTarget(command)
    let [path_sep, class_sep, expand_arg] = BanPython_GetTestSeparators(a:command)
    let target = expand(expand_arg) . class_sep . BanPython_GetCurrentPythonClassName()
    let g:test_target = substitute(target, '/', path_sep, 'g')
endfunction

function! BanPython_SetCurrentMethodAsTestTarget(command)
    let [path_sep, class_sep, expand_arg] = BanPython_GetTestSeparators(a:command)
    let target = expand(expand_arg) . class_sep . BanPython_GetCurrentPythonClassName() . class_sep . BanPython_GetCurrentPythonMethodName()
    let g:test_target = substitute(target, '/', path_sep, 'g')
endfunction

function! BanPython_SetCurrentFunctionAsTestTarget(command)
    let [path_sep, class_sep, expand_arg] = BanPython_GetTestSeparators(a:command)
    let target = expand(expand_arg) . class_sep . BanPython_GetCurrentPythonFunctionName()
    let g:test_target = substitute(target, '/', path_sep, 'g')
endfunction

function! BanPython_BuildTestCommand(command, target)
    " The {{ target }} part is used mainly with 'make test'.
    " As you know we can't pass arguments to 'make' as we do to shell scripts.
    " The easiest way is setting an environment variable and call 'make'.
    " So, we use the 'var=value command' syntax.
    "
    " Let's see an example.
    "
    " command: target='--pyargs {{ target }}' make test
    " target: some.package.module::Class::test_method
    "
    " Becomes
    "
    " target='--pyargs some.package.module::Class::test_method' make test
    "

    if a:command =~ '{{ target }}'
        let x = substitute(a:command, '{{ target }}', a:target, 'g')
        return 'eval "'. x .'"'
    endif
    return a:command .' '. a:target
endfunction

function! BanPython_TransformSelectedTextIntoFilename()
    execute 'normal gv"sy'
    return substitute(@s, '\.', '/', 'ge') .'.py'
endfunction


" ==================================================
" Autocommands
" ==================================================

augroup quickfix
    autocmd!
    autocmd QuickFixCmdPost [^l]* cwindow
    autocmd QuickFixCmdPost l* lwindow
    autocmd FileType qf setlocal nocursorline
augroup END

augroup aug_terminal_mode
    au!
    silent! autocmd TerminalWinOpen * setlocal nonumber norelativenumber
augroup END

augroup aug_ft_css
    au!
    autocmd FileType css setlocal tabstop=2
augroup END

augroup aug_ft_html
    au!
    autocmd FileType html,htmldjango setlocal tabstop=2
    autocmd FileType html,htmldjango let b:match_words = '<:>,{{:}},{%:%},{:},[:],(:),<!--:-->' .
        \ ',<\@<=\([^/][^ \t>]*\)[^>]*\%(>\|$\):<\@<=/\1>' .
        \ ',{% block:{% endblock,{% if:{% endif,{% for:{% endfor,{% macro:{% endmacro' .
        \ ',{% call:{% endcall,{% filter:{% endfilter,{% set:{% endset'
augroup END

augroup aug_ft_vue
    au!
    autocmd FileType vue setlocal tabstop=2
augroup END

augroup aug_ft_json
    au!
    autocmd FileType json setlocal tabstop=2
augroup END

augroup aug_ft_php
    au!
    autocmd FileType php setlocal foldmethod=marker foldmarker={,}
augroup END

augroup aug_ft_python
    au!
    autocmd FileType python call FtPython()
augroup END

function! FtPython()
    setlocal foldmethod=indent
    setlocal equalprg=~/.local/bin/python-style
    nnoremap <silent> <buffer> <leader>m :update<CR>:call flake8#Flake8()<CR>

    " Mapping to navigate to object definition in split window
    nnoremap <buffer> <localleader>D :split<CR>:call jedi#goto()<CR>

    " Mappings for classes, functions and docstrings text-objects
    xnoremap <buffer> ic <Plug>(textobj-python-class-i)
    onoremap <buffer> ic <Plug>(textobj-python-class-i)
    xnoremap <buffer> ac <Plug>(textobj-python-class-a)
    onoremap <buffer> ac <Plug>(textobj-python-class-a)
    xnoremap <buffer> if <Plug>(textobj-python-function-i)
    onoremap <buffer> if <Plug>(textobj-python-function-i)
    xnoremap <buffer> af <Plug>(textobj-python-function-a)
    onoremap <buffer> af <Plug>(textobj-python-function-a)
    xnoremap <buffer> ad <Plug>(PythonsenseOuterDocStringTextObject)
    onoremap <buffer> ad <Plug>(PythonsenseOuterDocStringTextObject)
    xnoremap <buffer> id <Plug>(PythonsenseInnerDocStringTextObject)
    onoremap <buffer> id <Plug>(PythonsenseInnerDocStringTextObject)

    " edit selected module name
    xnoremap <localleader>f :<C-U>let @s = BanPython_TransformSelectedTextIntoFilename() <CR>

    " Mappings to help with tests (this is a big section).
    " All mappings are prefixed with \t.
    if !exists('g:test_command')
        let g:test_command=''
        if $VIM_TEST_COMMAND != ''
            let g:test_command = $VIM_TEST_COMMAND
        else
            if executable('pytest')
                " makes pytest the default test runner if it is present
                let g:test_command = 'pytest --pyargs'
            endif
        endif
    endif
    if !exists('g:test_target')
        let g:test_target = ''
    endif

    nnoremap t<CR> :wall <CR>:execute Ban_Run('run-test '. BanPython_BuildTestCommand(g:test_command, g:test_target))<CR>|" Run tests in current vim session
    nnoremap <silent> T<CR> :update<CR>:let _all_commands=g:test_command .' '. g:test_target<CR>:execute '!tmux send-keys -t .+ -l "run-with-time '. _all_commands .'"'<CR>:execute '!tmux send-keys -t .+ Enter'<CR><CR>|" Run tests in tmux next pane



    " \tC configure the test command (along with its arguments).
    " Examples below:
    "   - pytest --pyargs
    "   - python manage.py test -v 2
    "   - python -m unittest
    nnoremap <localleader>tC :let g:test_command='<c-r>=g:test_command<cr>'

    nnoremap <buffer> <localleader>tn :call BanPython_MakeValidPythonTestName() <CR>|" Make a test name from current line contents

    " Mark targets
    nnoremap <buffer> <localleader>ta :wall <CR>:call BanPython_SetAllSuiteAsTestTarget() <CR>:echo g:test_target. ' set as test target.'<CR>
    nnoremap <buffer> <localleader>tp :wall <CR>:call BanPython_SetCurrentPackageAsTestTarget(g:test_command) <CR>:echo g:test_target. ' set as test target.'<CR>
    nnoremap <buffer> <localleader>t% :wall <CR>:call BanPython_SetCurrentModuleAsTestTarget(g:test_command) <CR>:echo g:test_target. ' set as test target.'<CR>
    nnoremap <buffer> <localleader>tc :wall <CR>:call BanPython_SetCurrentClassAsTestTarget(g:test_command) <CR>:echo g:test_target. ' set as test target.'<CR>
    nnoremap <buffer> <localleader>tm :wall <CR>:call BanPython_SetCurrentMethodAsTestTarget(g:test_command) <CR>:echo g:test_target. ' set as test target.'<CR>
    nnoremap <buffer> <localleader>tf :wall <CR>:call BanPython_SetCurrentFunctionAsTestTarget(g:test_command) <CR>:echo g:test_target. ' set as test target.'<CR>

    nnoremap <silent> <localleader>tr
        \ :let _curpos = getcurpos()<CR>
        \ :call search('def test', 'besc')<CR>
        \ :execute 'normal b"sye'<CR>
        \ :let _curr_method = @s<CR>
        \ :let _target = substitute(expand('%'), '.*joe/tests/', '', '').'::'._curr_method<CR>
        \ :call setpos('.', _curpos)<CR>
        \ :execute '!tmux send-keys -t JOE:src.1 -l "t ' .trim(_target). '"'<CR>
        \ :execute '!tmux send-keys -t JOE:src.1 Enter'<CR><CR>
        \ :unlet _curpos _curr_method _target<CR>
        \|" Copy current filename and function/method to register z in pytest format (JOE specific)

    syn keyword pythonTodo          TODO FIXME NOTE contained
    hi! link pythonBuiltin Statement
    hi! link pythonDocTest2 Comment
endfunction

augroup aug_ft_make
    au!
    autocmd FileType make setlocal noexpandtab
augroup END

augroup aug_ft_fugitive
    au!
    autocmd FileType fugitive setlocal cursorline
augroup END

augroup aug_ft_gitcommit
    au!
    autocmd FileType gitcommit setlocal
    autocmd BufRead COMMIT_EDITMSG setlocal nocursorline
    autocmd BufRead COMMIT_EDITMSG call execute(['normal gg'])

    " go to next/prev file in commit
    autocmd FileType gitcommit nnoremap <silent> <buffer> ]] :call search('^diff\\|^# On branch', "z")<CR>ztzv
    autocmd FileType gitcommit nnoremap <silent> <buffer> [[ :call search('^diff\\|^# On branch', "b")<CR>ztzv

    " go to next/prev change
    autocmd FileType gitcommit nnoremap <silent> <buffer> <expr> ]c search('^@@', "zW") ? ':call search("^@@", "zW")\|normal zz<CR>' : ':echohl WarningMsg\|echo "Last chunck"\|echohl None<CR>'
    autocmd FileType gitcommit nnoremap <silent> <buffer> <expr> [c search('^@@', "bW") ? ':call search("^@@", "bW")\|normal zz<CR>' : ':echohl WarningMsg\|echo "First chunck"\|echohl None<CR>'
augroup END

augroup aug_list_items
    au!

    " add item
    autocmd FileType markdown,text inoremap <buffer> <localleader>i - [ ]<Space>

    " mark item as doing/done
    autocmd FileType markdown,text nnoremap <silent> <buffer> <localleader>* :keeppatterns :s/^\(\s*- \[\).]/\1*]/<CR>
    autocmd FileType markdown,text nnoremap <silent> <buffer> <localleader>x :keeppatterns :s/^\(\s*- \[\).]/\1x]/<CR>

    " go to next/previous list item (any level)
    autocmd FileType markdown,text nnoremap <silent> <buffer> ]- :call search('^\s*- ', "z")<CR>
    autocmd FileType markdown,text nnoremap <silent> <buffer> [- :call search('^\s*- ', "b")<CR>

    " go to next/previous sibling
    autocmd FileType markdown,text nnoremap <silent> <buffer> ]= ^:call search("^". strpart(getline("."), 0, col(".")), "z")<CR>
    autocmd FileType markdown,text nnoremap <silent> <buffer> [= ^:let _pat=strpart(getline("."), 0, col("."))<CR>0:call search("^". _pat, "b")<CR>

    " go to parent
    autocmd FileType markdown,text nnoremap <silent> <buffer> [_ ^:call search('\%<' .col("."). 'c\S', "b")<CR>
augroup END

augroup aug_viniciusban_journal
    au!

    " Journal file v2 behaviour and functions
    " ---------------------------------------

    " As time goes by, journal becomes bigger. This block speeds up its load time.
    autocmd BufReadPre  *journal*.md let b:journal_loaded=0
    autocmd BufReadPre  *journal*.md syntax off
    autocmd BufReadPost *journal*.md setlocal foldmethod=manual foldenable foldlevel=1
    autocmd CursorHold  *journal*.md
        \  if b:journal_loaded == 0
        \ |    setlocal foldmethod=expr
        \ |    syntax on
        \ |    let b:journal_loaded=1
        \ |endif

    " help
    autocmd BufReadPost *journal*.md noremap  <buffer> <localleader>?  :call BanJournal_ShowMappings()<CR>

    " task items
    autocmd BufReadPost *journal*.md inoremap <buffer> <localleader>t  <C-o>:call BanJournal_CreateTask($JOURNAL_PROJECT)<CR>
    autocmd BufReadPost *journal*.md inoremap <buffer> <localleader>T  <C-o>:call BanJournal_CreateTask('<project>')
    autocmd BufReadPost *journal*.md nnoremap <buffer> <localleader>*  :call BanJournal_StartCurrentTask()<CR>
    autocmd BufReadPost *journal*.md nnoremap <buffer> <localleader>a  :call BanJournal_ArchiveCurrentTask()<CR>
    autocmd BufReadPost *journal*.md nnoremap <buffer> <localleader>x  :call BanJournal_EndCurrentTask()<CR>
    autocmd BufReadPost *journal*.md nnoremap <buffer> <localleader>.  :call BanJournal_PauseCurrentTask()<CR>
    autocmd BufReadPost *journal*.md nnoremap <buffer> <localleader>l  :let _=strftime('%Y-%m-%d')<CR>:call BanJournal_ListTasksTouchedOnDate('=_<CR>')
    autocmd BufReadPost *journal*.md nnoremap <silent> <buffer> <C-]> :normal! m'<CR>:execute 'keeppatterns /\m^#\+ '. expand('<cword>')<CR>:normal! zvw<CR>|" Go to task definition

    " timestamp notes
    autocmd BufReadPost *journal*.md inoremap <buffer> <localleader>n <C-o>:call BanJournal_AddTimestampNoteToCurrentLine('', 'without_task_code')<CR>
    autocmd BufReadPost *journal*.md inoremap <buffer> <localleader>N <C-o>:call BanJournal_AddTimestampNoteToCurrentLine()<CR>
    autocmd BufReadPost *journal*.md nnoremap <silent> <buffer> [n 0:call search('^\d\d\d\d-\d\d-\d\d \w\w\w \d\?\d:\d\d', 'bs')<CR>|" Go to prev timestamp note
    autocmd BufReadPost *journal*.md nnoremap <silent> <buffer> ]n :call search('^\d\d\d\d-\d\d-\d\d \w\w\w \d\?\d:\d\d', 's')<CR>|" Go to next timestamp note

    " daily records
    autocmd BufReadPost *journal*.md inoremap <buffer> <localleader>d <C-o>:call BanJournal_StartANewDay($JOURNAL_PROJECT)<CR><Esc>A
    autocmd BufReadPost *journal*.md inoremap <buffer> <localleader>s <C-o>:call BanJournal_CreateTheTimesheetTaskInCurrentLine('<project>')



    " New journal file support functions
    " ----------------------------------

    function! BanJournal_ShowMappings()
        echom '      New:    task \t     day \d   timesheet \s'
        echom ' '
        echom '    Tasks:  create \t   start \*      finish \x'
        echom '           archive \a   pause \.     touched \l'
        echom ' '
        echom 'Timestamp:  create \n    prev [n        next ]n'
        echom '     Note: Set the $JOURNAL_PROJECT variable first'
    endfunction

    function! BanJournal_CreateTask(project)
        " Create a task in current line

        let lnum = line('.')
        call BanJournal_DoCreateTask(lnum, a:project, trim(getline(lnum)))
        call cursor(lnum, col('$'))
    endfunction

    function! BanJournal_StartCurrentTask()
        " Mark as doing. Create the task section in ACTIVE. Keep it in BACKLOG.

        let journal_task_patt = '^- \[.\] _\w\+_\>'
        let simple_task_patt = '^ *- \[.\] '
        let lnum = line('.')

        if match(getline(lnum), journal_task_patt) > -1
            " We must check if the task is a journal task first,
            " because the start of the search pattern is the same,
            " but the journal task has its code following the closing
            " bracket.
            call BanJournal_DoStartTaskAtLine(lnum)
            let task_code = BanJournal_GetTaskCodeForLine(lnum)
            let [_, last_lnum] = BanJournal_GetTaskSectionInterval(task_code)
            call cursor(last_lnum, 1000)
            normal zx
            return
        endif

        if match(getline(lnum), simple_task_patt) > -1
            call BanJournal_MarkTaskAtLineAsDoing(lnum)
            return
        endif

        echohl ErrorMsg | echom  'Error: Not a task' | echohl None
    endfunction

    function! BanJournal_EndCurrentTask()
        let journal_task_patt = '^- \[.\] _\w\+_\>'
        let simple_task_patt = '^ *- \[.\] '
        let lnum = line('.')

        if match(getline(lnum), journal_task_patt) == -1 && match(getline(lnum), simple_task_patt) > -1
            call BanJournal_MarkTaskAtLineAsDone(lnum)
            return
        endif

        let task_code = BanJournal_GetTaskCodeForLine(lnum)
        if task_code == ''
            echohl ErrorMsg | echom  'Error: Not a task' | echohl None
            return
        endif
        call BanJournal_DoEndTask(task_code)
        normal zv
    endfunction

    function! BanJournal_ArchiveCurrentTask()
        let lnum = line('.')
        let task_code = BanJournal_GetTaskCodeForLine(lnum)
        if task_code == ''
            echohl ErrorMsg | echom  'Error: Not a task' | echohl None
            return
        endif
        call BanJournal_DoArchiveTask(task_code)
        normal zv
    endfunction

    function! BanJournal_PauseCurrentTask()
        let lnum = line('.')
        let task_code = BanJournal_GetTaskCodeForLine(lnum)
        if task_code == ''
            echom 'Error: Not a task'
            return
        endif
        call BanJournal_DoPauseTask(task_code)
    endfunction

    function! BanJournal_AddTimestampNoteToCurrentLine(description = '', option = '')
        let lnum = line('.')
        call BanJournal_AddTimestampNoteToLine(lnum, a:description, a:option)
        call cursor(lnum, col('$'))
    endfunction

    function! BanJournal_CreateTheDailyTaskInCurrentLine()
        let lnum = line('.')
        let task_description = 'daily '. strftime('%Y-%m-%d %a')
        let day_of_week = strftime('%a')
        call BanJournal_DoCreateTask(lnum, 'daily', task_description, day_of_week)
        call BanJournal_MarkTaskAtLineAsDoing(lnum)
        call BanJournal_CopyTaskAtLineToActive(lnum)
        let task_code = BanJournal_GetTaskCodeForLine(lnum)
        let [_, last_lnum] = BanJournal_GetTaskSectionInterval(task_code)
        call append(last_lnum, '')
        call cursor(last_lnum + 2, 1)
    endfunction

    function! BanJournal_CreateTheTimesheetTaskInCurrentLine(project)
        let lnum = line('.')
        let task_description = a:project . ' timesheet '. strftime('%Y-%m-%d %a')
        let task_suffix = 'timesheet_'. strftime('%a')
        call BanJournal_DoCreateTask(lnum, a:project, task_description, task_suffix)
        call BanJournal_MarkTaskAtLineAsDoing(lnum)
        call BanJournal_CopyTaskAtLineToActive(lnum)
        call BanJournal_AddTimestampNoteWhenStartingTimesheetAtLine(lnum)
        let task_code = BanJournal_GetTaskCodeForLine(lnum)
        let [_, last_lnum] = BanJournal_GetTaskSectionInterval(task_code)
        call append(last_lnum, '')
        call cursor(last_lnum, 1000)
        normal zx
    endfunction

    function! BanJournal_StartANewDay(project)
        let lnum = line('.')
        call BanJournal_CreateTheDailyTaskInCurrentLine()
        call append(lnum, '')
        call cursor(lnum + 1, 1)
        call BanJournal_CreateTheTimesheetTaskInCurrentLine(a:project)
    endfunction

    function! BanJournal_DoCreateTask(lnum, project, description, task_suffix='')
        " Create a task in line `lnum`.
        "
        " Format: _{project}_{date}_{suffix}_

        let template = '- [ ] {task_code} {description}'
        let task_code = BanJournal_BuildTaskCode(a:project, a:task_suffix)
        let new_line = template

        let new_line = substitute(new_line, '{task_code}', task_code, '')
        let new_line = substitute(new_line, '{description}', a:description, '')

        call setline(a:lnum, new_line)
    endfunction

    function! BanJournal_DoStartTaskAtLine(lnum)
        " Start the task at `lnum` line.

        let lnum = line('.')
        let task_code = BanJournal_GetTaskCodeForLine(lnum)
        let [first_line, _] = BanJournal_GetTaskSectionInterval(task_code)

        call BanJournal_AddStartDateToTaskTitleAtLine(lnum)
        call BanJournal_MarkTaskAtLineAsDoing(lnum)
        if first_line == 0
            call BanJournal_CopyTaskAtLineToActive(lnum)
        endif
        call BanJournal_AddTimestampNoteWhenStartingTaskAtLine(lnum)
        normal zx
    endfunction

    function! BanJournal_DoEndTask(task_code)
        " Mark task as ended and register the timestamp

        let task_item_lnum = BanJournal_FindTaskItemWithTaskCode(a:task_code)
        call BanJournal_MarkTaskAtLineAsDone(task_item_lnum)
        call BanJournal_AddEndDateToTaskTitle(a:task_code)
        call BanJournal_AddTimestampNoteWhenFinishingTask(a:task_code)
    endfunction

    function! BanJournal_DoArchiveTask(task_code)
        " Remove from BACKLOG. Move from ACTIVE to ARCHIVE.

        let task_item_lnum = BanJournal_FindTaskItemWithTaskCode(a:task_code)
        execute task_item_lnum . 'delete _'
        call BanJournal_MoveTaskToArchive(a:task_code)
    endfunction

    function! BanJournal_DoPauseTask(task_code)
        " Mark task as paused.

        let task_item_lnum = BanJournal_FindTaskItemWithTaskCode(a:task_code)
        call BanJournal_MarkTaskAtLineAsPaused(task_item_lnum)
        call BanJournal_AddTimestampNoteWhenPausingTask(a:task_code)
    endfunction

    function! BanJournal_AddTimestampNoteToLine(lnum, description = '', ...)
        if count(a:000, 'without_task_code') == 0
            let template = '{today} {weekday} {now} {task_code}{description}'
            let task_code = BanJournal_GetTaskCodeForLine(a:lnum)
        else
            let template = '{today} {weekday} {now}{description}'
            let task_code = ''
        endif
        let new_line = template

        if empty(a:description)
            let description = ''
        else
            let description = ' '. a:description
        endif

        let new_line = substitute(new_line, '{today}', strftime("%Y-%m-%d"), '')
        let new_line = substitute(new_line, '{weekday}', strftime("%a"), '')
        let new_line = substitute(new_line, '{now}', strftime("%H:%M"), '')
        let new_line = substitute(new_line, '{task_code}', task_code, '')
        let new_line = substitute(new_line, '{description}', description, '')

        call setline(a:lnum, new_line)
    endfunction

    function! BanJournal_BuildTaskCode(project, suffix='')
        " Assemble different pieces to build a task code.
        let template = '_{project}_{today}_{suffix}_'
        if a:suffix == ''
            let suffix = BanJournal_CreateRandomCodeWithLength(2)
        else
            let suffix = a:suffix
        endif

        let task_code = template
        let task_code = substitute(task_code, '{project}', a:project, '')
        let task_code = substitute(task_code, '{today}', strftime("%y%m%d"), '')
        let task_code = substitute(task_code, '{suffix}', suffix, '')
        return task_code
    endfunction

    function! BanJournal_CreateRandomCodeWithLength(length)
        " Create a random code with `length` chars.
        let chars = 'abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'
        let len_chars = len(chars)
        let result = []
        for _ in range(a:length)
            let i = rand() % len_chars
            call add(result, chars[i])
        endfor
        return join(result, '')
    endfunction

    function! BanJournal_FindTaskItemWithTaskCode(task_code)
        let item_lnum = search('^- \[.\] '. a:task_code, 'n')
        return item_lnum
    endfunction

    function! BanJournal_GetTaskCodeForLine(lnum)
        let task_code = BanJournal_GetTaskCodeFromItemList(a:lnum)
        if task_code == ''
            let task_code = BanJournal_GetTaskCodeFromInsideTaskSection(a:lnum)
        endif

        return task_code
    endfunction

    function! BanJournal_GetTaskCodeFromItemList(lnum)
        let pattern = '^- \[.\] \(_\w\+_\)\W'
        let matches = matchlist(getline(a:lnum), pattern)
        if empty(matches)
            return ''
        endif
        return matches[1]
    endfunction

    function! BanJournal_GetTaskCodeFromInsideTaskSection(lnum)
        " Task codes are in level 2 heading
        let pattern = '^## \(_\w\+_\)\W'
        let initial_lnum = line('.')

        call cursor(a:lnum, 1)
        let task_first_lnum = search(pattern, 'bcnW')
        call cursor(initial_lnum, 1)

        if task_first_lnum == 0
            return ''
        endif

        let matches = matchlist(getline(task_first_lnum), pattern)
        if empty(matches)
            return ''
        endif
        return matches[1]
    endfunction

    function! BanJournal_AddStartDateToTaskTitleAtLine(lnum)
        " Add note in task about when started doing: (#start:YYYY-MM-DD)
        let line_template = '{previous_contents} {note}'
        let note_template = '(#start:{today})'

        let note = note_template
        let note = substitute(note, '{today}', strftime('%Y-%m-%d'), '')

        let new_line = line_template
        let new_line = substitute(new_line, '{previous_contents}', getline(a:lnum), '')
        let new_line = substitute(new_line, '{note}', note, '')

        call setline(a:lnum, new_line)

        " Add start date to task title if it already exists in ACTIVE
        let task_code = BanJournal_GetTaskCodeForLine(a:lnum)
        let [title_lnum, _] = BanJournal_GetTaskSectionInterval(task_code)
        if title_lnum == 0
            return
        endif

        let new_title = line_template
        let new_title = substitute(new_title, '{previous_contents}', getline(title_lnum), '')
        let new_title = substitute(new_title, '{note}', note, '')
        call setline(title_lnum, new_title)
    endfunction

    function! BanJournal_MarkTaskAtLineAsDoing(lnum)
        let contents = getline(a:lnum)
        let new_line= substitute(contents, '\[.\] ', '\[*\] ', '')
        call setline(a:lnum, new_line)
    endfunction

    function! BanJournal_MarkTaskAtLineAsDone(lnum)
        let new_line= substitute(getline(a:lnum), '\[.\] ', '\[x\] ', '')
        call setline(a:lnum, new_line)
    endfunction

    function! BanJournal_MarkTaskAtLineAsPaused(lnum)
        let contents = getline(a:lnum)
        let new_line= substitute(contents, '\[.\] ', '\[.\] ', '')
        call setline(a:lnum, new_line)
    endfunction

    function! BanJournal_CopyTaskAtLineToActive(lnum)
        let task_item = getline(a:lnum)
        let task_section_heading = substitute(task_item, '^- \[.\]', '##', '')

        let active_section_lnum = search('^# ACTIVE', 'n')
        call append(active_section_lnum, ['', task_section_heading, ''])
    endfunction

    function! BanJournal_AddTimestampNoteWhenStartingTaskAtLine(lnum)
        let task_code = BanJournal_GetTaskCodeForLine(a:lnum)
        let [_, last_lnum] = BanJournal_GetTaskSectionInterval(task_code)
        let timestamp_lnum = last_lnum + 2
        call BanJournal_AddTimestampNoteToLine(timestamp_lnum, '#start', 'without_task_code')
        call append(timestamp_lnum, ['', ''])
    endfunction

    function! BanJournal_AddTimestampNoteWhenStartingTimesheetAtLine(lnum)
        let task_code = BanJournal_GetTaskCodeForLine(a:lnum)
        let [first_lnum, _] = BanJournal_GetTaskSectionInterval(task_code)
        let timestamp_lnum = first_lnum + 2
        call BanJournal_AddTimestampNoteToLine(timestamp_lnum, '-', 'without_task_code')
    endfunction

    function! BanJournal_MoveTaskToArchive(task_code)
        let initial_lnum = line('.')
        let archive_section_lnum = search('^# ARCHIVE', 'nw')
        let [first_lnum, last_lnum] = BanJournal_GetTaskSectionInterval(a:task_code)

        if first_lnum > archive_section_lnum
            " for some reason, the task is already in ARCHIVE
            return
        endif

        execute first_lnum .','. last_lnum .'move '. (archive_section_lnum + 1)
        call cursor(initial_lnum, 1)
    endfunction

    function! BanJournal_AddEndDateToTaskTitle(task_code)
        " Add note in task about when finished it doing: #end:YYYY-MM-DD
        let template = ' #end:{today}'

        let [first_lnum, _] = BanJournal_GetTaskSectionInterval(a:task_code)

        let note = template
        let note = substitute(note, '{today}', strftime('%Y-%m-%d'), '')
        let title_with_note = substitute(getline(first_lnum), '\()\)$', note.'\1', '')
        call setline(first_lnum, title_with_note)
    endfunction

    function! BanJournal_AddTimestampNoteWhenFinishingTask(task_code)
        let [_, last_lnum] = BanJournal_GetTaskSectionInterval(a:task_code)
        call append(last_lnum, ['', '', '', ''])
        call BanJournal_AddTimestampNoteToLine(last_lnum + 2, '#end', 'without_task_code')
    endfunction

    function! BanJournal_AddTimestampNoteWhenPausingTask(task_code)
        let [_, last_lnum] = BanJournal_GetTaskSectionInterval(a:task_code)
        let note_lnum = last_lnum + 2
        call append(note_lnum, ['', ''])
        call BanJournal_AddTimestampNoteToLine(note_lnum, '#paused', 'without_task_code')
        call cursor(note_lnum, 1)
        normal zv
    endfunction

    function! BanJournal_GetTaskSectionInterval(task_code)
        let initial_lnum = line('.')

        let task_first_lnum = search('^## '. a:task_code, 'nw')
        call cursor(task_first_lnum, 1)

        let next_section_lnum = search('^##\? ', 'nW')
        if next_section_lnum == 0
            call cursor(line('$'), 1000)
        else
            call cursor(next_section_lnum, 1)
        endif

        let task_last_lnum = search('^.', 'bnW')
        call cursor(initial_lnum, 1)

        return [task_first_lnum, task_last_lnum]
    endfunction

    function! BanJournal_ListTasksTouchedOnDate(date_arg)
        " Use location list to show all the tasks I have worked on that date.
        let v:errmsg = ''
        silent! execute 'lvimgrep '. a:date_arg . ' '. expand('%')

        if v:errmsg != ''
            echohl ErrorMsg | echom 'Nothing found for ' . a:date_arg | echohl None
            return
        endif

        let tasks_touched = {}

        for item in getloclist(0)
            let [lnum, text] = [item['lnum'], item['text']]

            if match(text, '^- \[.\] ') > -1
                " line is a task item
                let matches = matchlist(text, ' \(_\w\{-\}_\)\>.\(.*\)')
                let task_code = matches[1]
                let description = matches[2]
            elseif match(text, '^## ') > -1
                " line is the start of a task session
                let matches = matchlist(text, ' \(_\w\{-\}_\)\>.\(.*\)')
                let task_code = matches[1]
                let description = matches[2]
            elseif match(text, '^\d\d\d\d-\d\d-\d\d \w\w\w \d\d:\d\d') > -1
                " line is a timestamp note
                let notes = ''

                let matches = matchlist(text, '^\d\d\d\d-\d\d-\d\d \w\w\w \d\d:\d\d\(.*\)')
                if matches[1] != ''
                    let notes = ' ' . trim(matches[1])
                endif

                let task_code = BanJournal_GetTaskCodeFromInsideTaskSection(lnum)

                let [first_lnum, _] = BanJournal_GetTaskSectionInterval(task_code)
                let matches = matchlist(getline(first_lnum), ' _\w\{-\}_\>.\(.*\)')
                let task_description = trim(matches[1])

                " Get subsection title to show in location list
                let initial_lnum = line('.')
                call cursor(lnum, 1)
                let subsection_lnum = search('^#', 'bnW', first_lnum)
                call cursor(initial_lnum, 1)
                if subsection_lnum <= first_lnum
                    let subsection_title = ''
                else
                    let matches = matchlist(getline(subsection_lnum), '^#\+ \(.\+\)')
                    let subsection_title = ' (' . matches[1] . ')'
                endif

                if subsection_title == ''
                    let description = task_description . notes
                else
                    let description = task_description . subsection_title . notes
                endif
            else
                continue
            endif

            if match(task_code, '_daily_\|_timesheet_') > -1
                " ignore daily and timesheet tasks
                continue
            endif

            let tasks_touched[task_code] = {'lnum': lnum, 'text': description, 'task_code': task_code}
        endfor

        let sorted_list = sort(values(tasks_touched), 'BanJournal_SortListOfTasksTouchedOnDateByLnum')
        let new_items = []
        let filename = expand('%')

        for item in sorted_list
            call add(new_items, {
                \ 'filename': filename,
                \ 'module': item['task_code'],
                \ 'lnum': item['lnum'],
                \ 'text': item['text']
                \})
        endfor
        call setloclist(0, [], 'r', {'title': 'Tasks for '. a:date_arg, 'items': new_items})
        lopen
    endfunction

    function! BanJournal_SortListOfTasksTouchedOnDateByLnum(first, second)
        if a:first['lnum'] < a:second['lnum']
            return -1
        endif
        return 1
    endfunction

augroup END

augroup aug_ft_sh
    au!
    autocmd FileType sh setlocal noexpandtab
augroup END

augroup aug_quickscope_colors
    autocmd!
    autocmd ColorScheme * highlight QuickScopePrimary guifg=Cyan gui=underline,bold ctermfg=Cyan cterm=underline
    autocmd ColorScheme * highlight QuickScopeSecondary guifg=Magenta gui=underline,bold ctermfg=Magenta cterm=underline
augroup END


" ==================================================
" Global mappings
" ==================================================

" General mappings
nnoremap <leader>0 :echo 'hi<' . synIDattr(synID(line('.'),col('.'),1),'name') . '> trans<'
    \ . synIDattr(synID(line('.'),col('.'),0),'name') . '> lo<'
    \ . synIDattr(synIDtrans(synID(line('.'),col('.'),1)),'name') . '>'<CR>
    \|" Show highlight group of word under cursor

nnoremap <leader>T :!ctags -R --exclude=.git --exclude=__pycache__ --exclude=.pytest_cache --exclude=swagger-ui --languages=-json --tag-relative=yes -f ./.git/tags . &<CR>|" build tags for the project

" Show/hide helpers
nnoremap <leader>' :NERDTreeToggle<CR>
nnoremap <leader>1 :NERDTreeVCS<CR>
nnoremap <leader>! :NERDTreeFind<CR>
nnoremap <leader>2 :GFiles<CR>
nnoremap <leader>3 :Buffers<CR>
nnoremap <leader>4 :TagbarOpen j<CR>
nnoremap <leader>$ :TagbarToggle<CR>
nnoremap <expr> <leader>q empty(filter(getwininfo(), 'v:val.quickfix')) ? ':copen<CR>' : ':cclose<CR>'|" Show/hide quickfix window
nnoremap <expr> <leader>l empty(filter(getwininfo(), 'v:val.loclist')) ? ':lopen<CR>' : ':lclose<CR>'|" Show/hide location list
nnoremap <BS> :nohlsearch<CR>
nnoremap <leader>< :QuickScopeToggle<CR>|" Show/hide quick scope
nnoremap <leader>* :set hlsearch<bar>:let @/=expand('<cword>').'\c'<CR>|" Highlight word under cursor without moving it
nnoremap <leader><leader> :setlocal cursorline!<CR>

" editing
inoremap KJ <C-Bslash><C-N>|" back to normal mode
nnoremap <leader>d :call DuplicateLine("normal")<CR>
vnoremap <leader>d :<C-U>call DuplicateLine("visual")<CR>
function! DuplicateLine(mode)
    if a:mode == "normal"
        let _pos = col('.')
        copy .
        execute 'normal ' ._pos. '|'
    elseif a:mode == "visual"
        '<,'>copy '>
        normal '>j
    endif
endfunction

nnoremap <leader>D :call DuplicateAndCommentLine("normal")<CR>
vnoremap <leader>D :<C-U>call DuplicateAndCommentLine("visual")<CR>
function! DuplicateAndCommentLine(mode)
    if a:mode == "normal"
        let _pos = col('.')
        copy .
        normal k
        .Commentary
        normal j
        execute 'normal ' ._pos. '|'
    elseif a:mode == "visual"
        '<,'>copy '>
        normal gv
        '<,'>Commentary
        execute "normal \<Esc>"
        normal '>j
    endif
endfunction

vnoremap gC :call InvertCommentOnRangeOfLines("visual")<CR>
nnoremap gC :set operatorfunc=InvertCommentOnRangeOfLines<CR>g@
nnoremap gCC :call InvertCommentOnRangeOfLines("normal")<CR>
function! InvertCommentOnRangeOfLines(mode) range
    if a:mode == "visual"
        let first_lnum = a:firstline
        let last_lnum = a:lastline
    elseif a:mode == "normal"
        let first_lnum = a:firstline
        let last_lnum = a:lastline
    else
        let first_lnum = line("'[")
        let last_lnum = line("']")
    endif

    for lnum in range(first_lnum, last_lnum)
        execute lnum ."Commentary"
    endfor
endfunction

nnoremap <leader><Space> :call IsolateLineWithSpacesAround("normal")<CR>
vnoremap <leader><Space> :call IsolateLineWithSpacesAround("visual")<CR>
function! IsolateLineWithSpacesAround(mode) range
    call append(a:lastline, ['----------- focus here ^', ''])
    execute a:lastline+1 .'Commentary'
    call append(a:firstline -1, ['', '----------- focus here v'])
    execute a:firstline+1 .'Commentary'
    if a:mode == "visual"
        normal gv
    endif
endfunction

nnoremap <C-j> :call MoveLine("normal", "down")<CR>
vnoremap <C-j> :<C-U>call MoveLine("visual", "down")<CR>
nnoremap <C-k> :call MoveLine("normal", "up")<CR>
vnoremap <C-k> :<C-U>call MoveLine("visual", "up")<CR>
function! MoveLine(mode, direction)
    let offset = #{down:"+1", up:"-2"}
    if a:mode == "normal"
        execute 'move .' .offset[a:direction]
    elseif a:mode == "visual"
        let target = #{down:"'>", up:"'<"}
        execute "'<,'>move " .target[a:direction] .offset[a:direction]
        normal gv
    endif
endfunction

" file and buffer
nnoremap <leader>w :update<CR>
nnoremap <leader>W :saveas! %:p.copy<CR>| " duplicate current file
nnoremap <silent> <leader>= :update<CR>:let _state=winsaveview()<CR>gg=G:call winrestview(_state)<CR>:unlet _state<CR>|" Format all the source code and move back to original position
nnoremap <silent> <leader>m :update<CR>:make %<CR>

" navigation
nnoremap <Space> <C-F>
nnoremap ]q :cnext<CR>|" go to next line in quickfix
nnoremap [q :cprevious<CR>|" go to previous line in quickfix
nnoremap ]l :lnext<CR>|" go to next line in location list
nnoremap [l :lprevious<CR>|" go to previous line in location list
nnoremap ]a :next<CR>
nnoremap [a :previous<CR>

" clipboard
if !has('clipboard') && executable('clip.exe')
    vnoremap <leader>y "sy:call system('clip.exe', @s)<CR>|" Copy to Windows clipboard under WSL
else
    vnoremap <leader>y "+y
endif

" git
nnoremap <leader>gs :Git<CR>
nnoremap <leader>ga :Git add %<CR>
nnoremap <leader>gA :Git reset -- %<CR>
nnoremap <leader>gc :keepalt Git commit -v <CR>
nnoremap <leader>gC :keepalt Git commit -v --amend <CR>
nnoremap <leader>g= :keepalt Git diff % <CR>:wincmd _<CR>:setlocal bufhidden=wipe buftype=nowrite readonly nobuflisted<CR>
nnoremap <leader>gp gg:Ghdiffsplit <CR>
nnoremap <leader>gl :let _tmpfile=tempname()<bar>:silent execute '!git l -50 >'._tmpfile<bar>:silent execute 'keepalt split '._tmpfile<bar>:wincmd _<bar>:setlocal bufhidden=wipe buftype=nowrite readonly nobuflisted<bar>:unlet _tmpfile<bar>:redraw!<CR>

" toggle options
nnoremap <silent> <leader>oe :call Ban_SetDefaultEditOptions()<CR>
nnoremap <silent> <leader>od :call Ban_SetDefaultDiffOptions()<CR>
nnoremap <silent> <leader>ocl :let _grps={synIDattr(hlID("customDarkCursorLine"), "bg"): 'customLightCursorLine', synIDattr(hlID("customLightCursorLine"), "bg"): 'customDarkCursorLine'}<bar>:let _new_grp=_grps[synIDattr(synIDtrans(hlID("CursorLine")), "bg")]<bar>:execute 'hi! link CursorLine '._new_grp<bar>unlet _grps _new_grp<bar>redraw!<CR>|" change CursorLine based on a dictionary with keys inverted with highlight group names. Key is bgcolor. Value is highlight group name.
nnoremap <silent> <leader>on :setlocal number!<CR>
nnoremap <silent> <leader>op :set paste!<CR>:set paste?<CR>
nnoremap <silent> <leader>ow :setlocal wrap!<CR>:set wrap?<CR>
nnoremap <leader>o :setlocal


" ==================================================
" Options
" ==================================================

" elements of interface
set number
set scrolloff=0
set lazyredraw
set laststatus=2
set showtabline=2

set hlsearch
set shortmess-=S
set list listchars=tab:››,trail:·,nbsp:·,extends:→,precedes:←
set cpoptions+=n showbreak=→\ 

set wildmode=list:longest,full

set mouse=a
if !has('nvim')
    set ttymouse=xterm2  | " enable resizing windows with the mouse
endif

" syntax and colors
syntax reset
colorscheme white_on_black

if exists('+termguicolors')
  " truecolor under tmux
  let &t_8f = "\<Esc>[38;2;%lu;%lu;%lum"
  let &t_8b = "\<Esc>[48;2;%lu;%lu;%lum"
endif

" sane editing
set expandtab tabstop=4 softtabstop=4 shiftwidth=0 | " <TAB> is 4 spaces, once for all!
set ignorecase smartcase tagcase=smart
set nofoldenable foldlevel=1
if !exists('g:loaded_vimrc')
    set foldmethod=indent
endif
let g:markdown_folding = 1 | " enable folded headings in markdown files

" other options
set hidden
set grepprg=grep\ -nI\ --exclude-dir=.git\ --exclude-dir=venv\ --exclude-dir=__pycache__\ --exclude-dir='*.egg-info'\ --exclude-dir=.vagrant\ $*\ /dev/null
set directory=~/tmp//
set tags+=.git/tags | " The filename doesn't start with './'. See `:h 'tags'` for details.
set modeline


function! Ban_SetDefaultEditOptions(scope = 'local')
    let command = (a:scope == 'global') ?  'set' : 'setlocal'
    execute command . ' wrap wrapscan hlsearch cursorline nocursorcolumn number norelativenumber'
endfunction


function! Ban_SetDefaultDiffOptions()
    let curtab_winids = map(filter(getwininfo(), 'v:val.tabnr == tabpagenr()'), 'v:val.winid')
    let are_diff_windows = map(copy(curtab_winids), {idx, winid -> {'winid': winid, 'is_diff': getwinvar(winid, '&diff')}})
    let only_diff_windows = filter(copy(are_diff_windows), 'v:val.is_diff == 1')
    call map(only_diff_windows, {idx, item -> win_execute(item.winid, 'setlocal wrap wrapscan hlsearch nocursorline nocursorcolumn nonumber relativenumber')})
endfunction

call Ban_SetDefaultEditOptions('global')


" Show filename without path in tabline
" -------------------------------------

function! MyTabLine()
    let tabline_value = ''
    for tabnr in range(1, tabpagenr('$'))
        " select the highlighting
        if tabnr == tabpagenr()
            let tabline_value .= '%#TabLineSel#'
        else
            let tabline_value .= '%#TabLine#'
        endif

        " set the tab page number (for mouse clicks)
        let tabline_value .= '%' . tabnr . 'T'

        " the label is made by MyTabLabel()
        let tabline_value .= ' %{MyTabLabel(' . tabnr . ')} '
    endfor

    " after the last tab fill with TabLineFill and reset tab page nr
    let tabline_value .= '%#TabLineFill#%T'

    return tabline_value
endfunction

function! MyTabLabel(tabnr)
    let buflist = tabpagebuflist(a:tabnr)
    let winnr = tabpagewinnr(a:tabnr)
    let current_bufnr = buflist[winnr - 1]

    let modified_indicator = ''
    " Add '+' if one of the buffers in the tab page is modified
    for bufnr in buflist
        if getbufvar(bufnr, "&modified")
            let modified_indicator = '+'
            break
        endif
    endfor

    " let filename_tail = fnamemodify(bufname(buflist[winnr - 1]), ':t')
    let current_bufname = bufname(current_bufnr)
    if current_bufname == ''
        if getbufvar(current_bufnr, '&buftype') == 'quickfix'
            let filename_tail = '[Quickfix List]'
        else
            let filename_tail = '[No Name]'
        endif
    else
        let filename_tail = fnamemodify(current_bufname, ':t')
    endif
    return a:tabnr .' '. modified_indicator . filename_tail
endfunction

set tabline=%!MyTabLine()


" Use a line cursor within insert mode and a block cursor everywhere else.
"
" Reference chart of values:
"   Ps = 0  -> blinking block.
"   Ps = 1  -> blinking block (default).
"   Ps = 2  -> steady block.
"   Ps = 3  -> blinking underline.
"   Ps = 4  -> steady underline.
"   Ps = 5  -> blinking bar (xterm).
"   Ps = 6  -> steady bar (xterm).
let &t_SI = "\e[6 q"
let &t_EI = "\e[2 q"


let g:loaded_vimrc=1
