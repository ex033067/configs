" leader keys
let mapleader=','
let maplocalleader='\'

" Start with vim defaults
unlet! skip_defaults_vim
source $VIMRUNTIME/defaults.vim


" ==================================================
" Plugins
" ==================================================
" install vim-plug:
" curl -fLo ~/.vim/autoload/plug.vim --create-dirs \
"    https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim

call plug#begin('~/.vim/bundle')
Plug 'viniciusban/vim-polyglot'  | " up to date syntax files
Plug 'viniciusban/vim-distractionfree-colorschemes'
Plug 'luochen1990/rainbow' | " colorize parentheses
Plug 'ap/vim-css-color'  | " show the color in CSS
Plug 'tpope/vim-commentary'  | " gcc, gc<motion>, {Visual}gc
Plug 'machakann/vim-sandwich'  | " sa, sd, sr
Plug 'andymass/vim-matchup'  | " %, g%, a%, i%, and more
Plug 'kana/vim-textobj-user' | " required by other text object plugins
Plug 'kana/vim-textobj-indent' | " ai, ii
Plug 'glts/vim-textobj-comment' | " ac, ic (remapped below to...)
Plug 'bps/vim-textobj-python' | " ac, ic, af, if.
Plug 'jeetsukumaran/vim-pythonsense' | " ad, id (docstring objects). See https://github.com/viniciusban/myconfigs/issues/1
Plug 'inkarkat/vim-ReplaceWithRegister'  | " <register>gr{motion}, {Visual}<register>gr
Plug 'tpope/vim-unimpaired'  | " [q, ]q, [e, ]e, etc.
Plug 'davidhalter/jedi-vim'
Plug 'SirVer/ultisnips'
Plug 'viniciusban/vim-ft-markdown'
Plug 'mattn/emmet-vim'
Plug 'tpope/vim-fugitive'
Plug 'junegunn/fzf', {'dir': '~/.vim/bundle/fzf', 'do': './install --all'}
Plug 'junegunn/fzf.vim'
Plug 'scrooloose/nerdtree'
Plug 'majutsushi/tagbar'
call plug#end()

" rainbow
let g:rainbow_active = 0

" vim-text-object-comment
omap aC <Plug>(textobj-comment-a)
xmap aC <Plug>(textobj-comment-a)
omap iC <Plug>(textobj-comment-i)
xmap iC <Plug>(textobj-comment-i)

" vim-textobj-python
let g:is_pythonsense_suppress_object_keymaps = 1
let g:is_pythonsense_suppress_motion_keymaps = 1

" jedi-vim
let g:jedi#popup_on_dot=0
let g:jedi#show_call_signatures_delay=100
let g:jedi#goto_command = '<localleader>jd'
let g:jedi#goto_assignments_command = '<localleader>jg'
let g:jedi#goto_stubs_command = '<localleader>js'
let g:jedi#rename_command = '<localleader>jr'
let g:jedi#usages_command = '<localleader>jn'

" ultisnips
let g:UltiSnipsSnippetDirectories=[$HOME.'/src/vim-snippets']

" emmet
let g:user_emmet_leader_key = '<C-\>'

" NERDTree
let NERDTreeIgnore=['__pycache__[[dir]]']
let NERDTreeHijackNetrw = 0


" ==================================================
" my own functions
" ==================================================

function! Ban_Run(command)
    " Run an external command using internal or external terminal

    if !exists('g:ban_run_internal')
        if has('gui_running')
            let g:ban_run_internal = 1
        elseif has('nvim')
            let g:ban_run_internal = 1
        else
            let g:ban_run_internal = 0
        endif
    endif

    let quote = "'"
    if g:ban_run_internal == 1
        if has('nvim')
            let prefix = 'tabnew | terminal '. &shell .' -c ' . quote
            let suffix = quote
        else
            let prefix = 'tabnew | terminal ++curwin ++shell '
            let suffix = ''
        endif
        let command = substitute(a:command, quote, "'\"\\'\"'", 'g')
        let command = substitute(command, '#', '\\#', 'g')
    else
        let prefix = '!'
        let command = a:command
        let suffix = ''
    endif

    return prefix . command . suffix
endfunction

function! BanPython_GetCurrentPythonClassName()
    execute "normal ms$?^class \<Enter>0w"
    nohls
    let class_name = expand('<cword>')
    execute 'normal g`s'
    return l:class_name
endfunction

function! BanPython_GetCurrentPythonMethodName()
    execute 'normal ms$?^ \+\(def\|async def\) \+test\w\+(\_s\{-}self?e' . "\<Enter>" . '3b'
    nohls
    let method_name = expand('<cword>')
    execute 'normal g`s'
    return l:method_name
endfunction

function! BanPython_GetCurrentPythonFunctionName()
    execute 'normal ms$?^\(def\|async def\) \+test\w\+(?e' . "\<Enter>" . 'b'
    nohls
    let function_name = expand('<cword>')
    execute 'normal g`s'
    return l:function_name
endfunction

function! BanPython_MakeValidPythonTestName()
    " Transform a phrase into a test method name.
    "
    " Transform this:
    "   show user name
    " Into this:
    "   def test_show_user_name(self):
    "
    let x=getline('.')
    let x=substitute(x, '\(\w\) ', '\1_', 'ge')
    let x=substitute(x, '-', '_', 'ge')
    let x=substitute(x, '\(\S\+\)', 'def test_\1(self):', '')
    call setline('.', x)
endfunction

function! BanPython_GetTestSeparator()
    if g:test_command =~ 'pytest'
        return '::'
    else
        return '.'
    endif
endfunction

function! BanPython_SetAllSuiteAsTestTarget()
    let g:test_target = ''
endfunction

function! BanPython_SetCurrentPackageAsTestTarget()
    let g:test_target = expand('%:.:h')
    let g:test_target = substitute(g:test_target, '/', '.', 'g')
endfunction

function! BanPython_SetCurrentModuleAsTestTarget()
    let g:test_target = expand('%:.:r')
    let g:test_target = substitute(g:test_target, '/', '.', 'g')
endfunction

function! BanPython_SetCurrentClassAsTestTarget()
    let sep = BanPython_GetTestSeparator()
    let g:test_target = expand('%:.:r') . sep . BanPython_GetCurrentPythonClassName()
    let g:test_target = substitute(g:test_target, '/', '.', 'g')
endfunction

function! BanPython_SetCurrentMethodAsTestTarget()
    let sep = BanPython_GetTestSeparator()
    let g:test_target = expand('%:.:r') . sep . BanPython_GetCurrentPythonClassName() . sep . BanPython_GetCurrentPythonMethodName()
    let g:test_target = substitute(g:test_target, '/', '.', 'g')
endfunction

function! BanPython_SetCurrentFunctionAsTestTarget()
    let sep = BanPython_GetTestSeparator()
    let g:test_target = expand('%:.:r') . sep . BanPython_GetCurrentPythonFunctionName()
    let g:test_target = substitute(g:test_target, '/', '.', 'g')
endfunction

function! BanPython_RunCurrentTestMethod()
    call BanPython_SetCurrentMethodAsTestTarget()
    let test_command = BanPython_BuildTestCommand(g:test_command, g:test_target)
    execute Ban_Run('run-test '. test_command)
endfunction

function! BanPython_RunCurrentTestFunction()
    call BanPython_SetCurrentFunctionAsTestTarget()
    let test_command = BanPython_BuildTestCommand(g:test_command, g:test_target)
    execute Ban_Run('run-test '. test_command)
endfunction

function! BanPython_RunCurrentTestCase()
    call BanPython_SetCurrentClassAsTestTarget()
    let test_command = BanPython_BuildTestCommand(g:test_command, g:test_target)
    execute Ban_Run('run-test '. test_command)
endfunction

function! BanPython_RunCurrentTestModule()
    call BanPython_SetCurrentModuleAsTestTarget()
    let test_command = BanPython_BuildTestCommand(g:test_command, g:test_target)
    execute Ban_Run('run-test '. test_command)
endfunction

function! BanPython_RunCurrentTestPackage()
    call BanPython_SetCurrentPackageAsTestTarget()
    let test_command = BanPython_BuildTestCommand(g:test_command, g:test_target)
    execute Ban_Run('run-test '. test_command)
endfunction

function! BanPython_RunAllTestSuite()
    call BanPython_SetAllSuiteAsTestTarget()
    let test_command = BanPython_BuildTestCommand(g:test_command, '')
    execute Ban_Run('run-test '. test_command)
endfunction

function! BanPython_BuildTestCommand(command, target)
    " The {{ target }} part is used mainly with 'make test'.
    " As you know we can't pass arguments to 'make' as we do to shell scripts.
    " The easiest way is setting an environment variable and call 'make'.
    " So, we use the 'var=value command' syntax.
    "
    " Let's see an example.
    "
    " command: target='--pyargs {{ target }}' make test
    " target: some.package.module::Class::test_method
    "
    " Becomes
    "
    " target='--pyargs some.package.module::Class::test_method' make test
    "

    if a:command =~ '{{ target }}'
        let x = substitute(a:command, '{{ target }}', a:target, 'g')
        return 'eval "'. x .'"'
    endif
    return a:command .' '. a:target
endfunction

function! BanPython_TransformSelectedTextIntoFilename()
    let unnamed_register = @"
    execute 'normal gvy'
    let selected_text = @"
    let @" = unnamed_register
    let filename = substitute(selected_text, '\.', '/', 'ge') .'.py'
    return filename
endfunction


" ==================================================
" Options
" ==================================================

" elements of interface
set number
set scrolloff=0
set hls

set list listchars=tab:››,trail:·,nbsp:·,extends:→,precedes:←
set cpoptions+=n showbreak=→\ 

set wildmode=list:longest,full

let &t_SI = "\<Esc>]12;green\x7" | " solid non-blinking cursor
let &t_SR = &t_SI
let &t_EI = &t_SI

set ttymouse=xterm2  | " enable resizing windows with the mouse

" syntax and colors
syntax reset
silent! colorscheme yellowonblack
if exists('+termguicolors')
  " truecolor under tmux
  let &t_8f = "\<Esc>[38;2;%lu;%lu;%lum"
  let &t_8b = "\<Esc>[48;2;%lu;%lu;%lum"
endif
set termguicolors

" sane editing
set expandtab tabstop=4 softtabstop=4 shiftwidth=0 | " <TAB> is 4 spaces, once for all!
set ignorecase smartcase
set foldenable foldmethod=indent foldlevel=2
let g:markdown_folding = 1 | " enable folded headings in markdown files

" other options
set hidden
set grepprg=ack\ --nogroup\ $* | " ack is better than grep


" ==================================================
" Global mappings
" ==================================================

" Show highlight group of word under cursor
map <leader>0 :echo 'hi<' . synIDattr(synID(line('.'),col('.'),1),'name') . '> trans<'
    \ . synIDattr(synID(line('.'),col('.'),0),'name') . '> lo<'
    \ . synIDattr(synIDtrans(synID(line('.'),col('.'),1)),'name') . '>'<CR>
map <leader>2 :NERDTreeToggle<CR>
map <leader>4 :execute 'colorscheme ' . g:next_colorscheme <CR>

" visual elements
map <leader><leader> :noh<CR>

" editing
noremap <leader>dl :let _r=@"<CR>yyp:let @"=_r<CR>| " duplicate line
map <leader>dc :let _r=@"<CR>yygccp:let @"=_r<CR>| " duplicate and comment line using vim-commentary
noremap <leader><Space><Space> m`O<Esc>0"_d$``o<Esc>0"_d$``| " isolate current line

" file and buffer
map <leader>w :update<CR>
map <leader>fd :saveas! %:p.copy<CR>| " duplicate current file
noremap <silent> <buffer> == :update<CR>gg=G

" navigation
noremap <Space> <C-F>

" clipboard
if !has('clipboard') && executable('clip.exe')
    " Use Windows clipboard under WSL
    vnoremap <leader>y "sy:call system('clip.exe', @s)<CR>
else
    vnoremap <leader>y "+y
endif

" git
map <leader>ga :terminal ++shell ++close git add % 
map <leader>gd :terminal ++shell git diff % <CR><C-W>_
map <leader>gc :terminal ++shell ++close git commit -v 
map <leader>gl :terminal ++shell ++noclose git l 


" ==================================================
" Autocommands
" ==================================================

augroup aug_terminal_mode
    au!
    silent! autocmd TerminalWinOpen * setlocal nonumber norelativenumber
    silent! autocmd TerminalOpen * setlocal nonumber norelativenumber
augroup END

augroup aug_ft_css
    au!
    autocmd FileType css setlocal tabstop=2
augroup END

augroup aug_ft_html
    au!
    autocmd FileType html,htmldjango setlocal foldlevel=4 tabstop=2
    autocmd FileType html,htmldjango let b:match_words = '<:>,{{:}},{%:%},{:},[:],(:),<!--:-->' .
        \ ',<\@<=\([^/][^ \t>]*\)[^>]*\%(>\|$\):<\@<=/\1>' .
        \ ',{% block:{% endblock,{% if:{% endif,{% for:{% endfor,{% macro:{% endmacro' .
        \ ',{% call:{% endcall,{% filter:{% endfilter,{% set:{% endset'
augroup END

augroup aug_ft_json
    au!
    autocmd FileType json setlocal tabstop=2
augroup END

augroup aug_ft_php
    au!
    autocmd FileType php setlocal foldmethod=marker foldmarker={,}
augroup END

augroup aug_ft_python
    au!
    autocmd FileType python call FtPython()
augroup END

function! FtPython()
    setlocal foldmethod=indent foldlevel=3
    if filereadable('Makefile')
        setlocal equalprg=make\ --no-print-directory\ --silent\ pep8
        setlocal makeprg=TARGET=%\ make\ --no-print-directory\ --silent
    elseif executable('pylint')
        setlocal equalprg=~/.local/bin/binscripts/python-style
        setlocal makeprg=pylint\ %
    elseif executable('flake8')
        setlocal equalprg=~/.local/bin/binscripts/python-style
        setlocal makeprg=flake8\ %
    endif
    map <buffer> <localleader>m :update<CR>:make %<CR>

    " Mappings for classes, functions and docstrings text-objects
    xmap <buffer> ic <Plug>(textobj-python-class-i)
    omap <buffer> ic <Plug>(textobj-python-class-i)
    xmap <buffer> ac <Plug>(textobj-python-class-a)
    omap <buffer> ac <Plug>(textobj-python-class-a)
    xmap <buffer> if <Plug>(textobj-python-function-i)
    omap <buffer> if <Plug>(textobj-python-function-i)
    xmap <buffer> af <Plug>(textobj-python-function-a)
    omap <buffer> af <Plug>(textobj-python-function-a)
    xmap <buffer> ad <Plug>(PythonsenseOuterDocStringTextObject)
    omap <buffer> ad <Plug>(PythonsenseOuterDocStringTextObject)
    xmap <buffer> id <Plug>(PythonsenseInnerDocStringTextObject)
    omap <buffer> id <Plug>(PythonsenseInnerDocStringTextObject)

    " edit selected module name
    xmap <localleader>f :<C-U>let @g = BanPython_TransformSelectedTextIntoFilename() <CR>

    " Mappings to help with tests (this is a big section).
    " All mappings are prefixed with \t.
    if !exists('g:test_command')
        let g:test_command=''
        if $DEV_TEST_COMMAND != ''
            let g:test_command = $DEV_TEST_COMMAND
        else
            if executable('pytest')
                " makes pytest the default test runner if it is present
                let g:test_command = 'pytest --pyargs'
            endif
        endif
    endif
    if !exists('g:test_target')
        let g:test_target = ''
    endif

    " \tt and \TT run tests.
    nmap <localleader>tt :wall <CR>:execute Ban_Run('run-test '. BanPython_BuildTestCommand(g:test_command, g:test_target))<CR>
    nmap <silent> <localleader>TT :update<CR>:execute '!tmux send-keys -t .+ -l "' .g:test_command. ' ' .g:test_target. '"'<CR>:execute '!tmux send-keys -t .+ Enter'<CR><CR>
    nmap t<CR> <localleader>tt
    nmap T<CR> <localleader>TT

    " \tC configure the test command (along with its arguments).
    " Examples:
    "   - pytest --pyargs
    "   - python manage.py test -v 2
    "   - python -m unittest
    map <localleader>tC :let g:test_command='<c-r>=g:test_command<cr>'

    " \tn Make a test name from current line contents
    map <buffer> <localleader>tn :call BanPython_MakeValidPythonTestName() <CR>

    " Mark the target and run tests
    map <buffer> <localleader>ta :wall <CR>:call BanPython_RunAllTestSuite() <CR>
    map <buffer> <localleader>tp :wall <CR>:call BanPython_RunCurrentTestPackage() <CR>
    map <buffer> <localleader>t% :wall <CR>:call BanPython_RunCurrentTestModule() <CR>
    map <buffer> <localleader>tc :wall <CR>:call BanPython_RunCurrentTestCase() <CR>
    map <buffer> <localleader>tm :wall <CR>:call BanPython_RunCurrentTestMethod() <CR>
    map <buffer> <localleader>tf :wall <CR>:call BanPython_RunCurrentTestFunction() <CR>

    " Only mark the target
    map <buffer> <localleader>TA :wall <CR>:call BanPython_SetAllSuiteAsTestTarget() <CR>:echo g:test_target. ' set as test target.'<CR>
    map <buffer> <localleader>TP :wall <CR>:call BanPython_SetCurrentPackageAsTestTarget() <CR>:echo g:test_target. ' set as test target.'<CR>
    map <buffer> <localleader>T% :wall <CR>:call BanPython_SetCurrentModuleAsTestTarget() <CR>:echo g:test_target. ' set as test target.'<CR>
    map <buffer> <localleader>TC :wall <CR>:call BanPython_SetCurrentClassAsTestTarget() <CR>:echo g:test_target. ' set as test target.'<CR>
    map <buffer> <localleader>TM :wall <CR>:call BanPython_SetCurrentMethodAsTestTarget() <CR>:echo g:test_target. ' set as test target.'<CR>
    map <buffer> <localleader>TF :wall <CR>:call BanPython_SetCurrentFunctionAsTestTarget() <CR>:echo g:test_target. ' set as test target.'<CR>

    " copy current filename and function/method to register z in pytest format (JOE specific)
    nmap <silent> <localleader>tr :let cursorpos = getcurpos() <CR>:call search('def test', 'besc') <CR>:execute 'normal bye' <CR>:let @z = substitute(expand('%'), '.*joe/tests/', '', '').'::'.getreg('"') <CR>:call setpos('.', cursorpos) <CR>:let test_cmd = "t " .trim(getreg('z'))<CR>:execute '!tmux send-keys -t JOE:src.1 -l "' .test_cmd. '"'<CR>:execute '!tmux send-keys -t JOE:src.1 Enter'<CR><CR>

    syn keyword pythonTodo          TODO FIXME NOTE contained
    hi! link pythonBuiltin Statement
    hi! link pythonDocTest2 Comment
endfunction

augroup aug_ft_make
    au!
    autocmd FileType make setlocal noexpandtab
augroup END

augroup aug_ft_fugitive
    au!
    autocmd FileType fugitive setlocal cursorline
augroup END

augroup aug_ft_gitcommit
    au!
    autocmd FileType gitcommit setlocal nofoldenable
    autocmd BufRead COMMIT_EDITMSG setlocal nocursorline
    " commit window in split view
    autocmd BufRead COMMIT_EDITMSG call execute(['normal gg','4split','wincmd b','/Changes to be committed:/','normal zt'])
    " save/discard and exit working with split view
    autocmd FileType gitcommit nmap <silent> <buffer> ZZ :w<CR>:bd<CR>
    autocmd FileType gitcommit nmap <silent> <buffer> ZQ ggdG:w<CR>:bd<CR>|" real discard the commit
    " go to next/prev file in commit
    autocmd FileType gitcommit nmap <silent> <buffer> ]] :let _lz=&lazyredraw<CR>:let _hls=&hlsearch<CR>:let _pat=@/<CR>:set nohlsearch lazyredraw<CR>$/Changes to be committed:\\|^diff/<CR>zt:let @/=_pat<CR>:let &hlsearch=_hls<CR>:noh<CR>:let &lazyredraw=_lz<CR>:unlet _lz _hls _pat<CR>
    autocmd FileType gitcommit nmap <silent> <buffer> [[ :let _lz=&lazyredraw<CR>:let _hls=&hlsearch<CR>:let _pat=@/<CR>:set nohlsearch lazyredraw<CR>?Changes to be committed:\\|^diff?<CR>zt:let @/=_pat<CR>:let &hlsearch=_hls<CR>:noh<CR>:let &lazyredraw=_lz<CR>:unlet _lz _hls _pat<CR>
augroup END

augroup aug_list_items
    au!
    " add item
    autocmd FileType markdown,text nmap <buffer> <localleader>ia o- [ ] 
    autocmd FileType markdown,text imap <buffer> <localleader>ia - [ ] 
    " mark item as doing
    autocmd FileType markdown,text nmap <silent> <buffer> <localleader>i* :let _lz=&lazyredraw<CR>:let _hls=&hlsearch<CR>:let _pat=@/<CR>:set nohlsearch lazyredraw<CR>:s/^\(\s*- \[\).]/\1*]/<CR>:let @/=_pat<CR>:let &hlsearch=_hls<CR>:noh<CR>:let &lazyredraw=_lz<CR>:unlet _lz _hls _pat<CR>
    " mark item as done
    autocmd FileType markdown,text nmap <silent> <buffer> <localleader>ix :let _lz=&lazyredraw<CR>:let _hls=&hlsearch<CR>:let _pat=@/<CR>:set nohlsearch lazyredraw<CR>:s/^\(\s*- \[\).]/\1x]/<CR>:let @/=_pat<CR>:let &hlsearch=_hls<CR>:noh<CR>:let &lazyredraw=_lz<CR>:unlet _lz _hls _pat<CR>

    " go to next/previous list item (any level)
    autocmd FileType markdown,text nmap <silent> <buffer> ]m :let _lz=&lazyredraw<CR>:let _hls=&hlsearch<CR>:let _pat=@/<CR>:set nohlsearch lazyredraw<CR>/^\s*- /<CR>^:let @/=_pat<CR>:let &hlsearch=_hls<CR>:noh<CR>:let &lazyredraw=_lz<CR>:unlet _lz _hls _pat<CR>
    autocmd FileType markdown,text nmap <silent> <buffer> [m :let _lz=&lazyredraw<CR>:let _hls=&hlsearch<CR>:let _pat=@/<CR>:set nohlsearch lazyredraw<CR>0?^\s*- ?<CR>^:let @/=_pat<CR>:let &hlsearch=_hls<CR>:noh<CR>:let &lazyredraw=_lz<CR>:unlet _lz _hls _pat<CR>
    " go to next/previous sibling (same level)
    autocmd FileType markdown,text nmap <silent> <buffer> ]} :let _lz=&lazyredraw<CR>:let _hls=&hlsearch<CR>:let _pat=@/<CR>:set nohlsearch lazyredraw<CR>^:execute '/^' .strpart(getline('.'), 0, col('.')). '/'<CR><CR>^:let @/=_pat<CR>:let &hlsearch=_hls<CR>:noh<CR>:let &lazyredraw=_lz<CR>:unlet _lz _hls _pat<CR>
    autocmd FileType markdown,text nmap <silent> <buffer> [{ :let _lz=&lazyredraw<CR>:let _hls=&hlsearch<CR>:let _pat=@/<CR>:set nohlsearch lazyredraw<CR>^:execute '?^' .strpart(getline('.'), 0, col('.')). '?'<CR><CR>^:let @/=_pat<CR>:let &hlsearch=_hls<CR>:noh<CR>:let &lazyredraw=_lz<CR>:unlet _lz _hls _pat<CR>
    " go to parent
    autocmd FileType markdown,text nmap <silent> <buffer> [( :let _lz=&lazyredraw<CR>:let _hls=&hlsearch<CR>:let _pat=@/<CR>:set nohlsearch lazyredraw<CR>^:execute '?\%<' .col('.'). 'c\S'<CR><CR>^:let @/=_pat<CR>:let &hlsearch=_hls<CR>:noh<CR>:let &lazyredraw=_lz<CR>:unlet _lz _hls _pat<CR>
augroup END
