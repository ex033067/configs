#
# Due to property file syntax, a semicolon starts a comment.
#
# To use a semicolon in aliases, enclose it in double quotes.
#

[user]
        name = viniciusban
        email = viniciusban@gmail.com

[versionsort]
    prereleaseSuffix = -alpha
    prereleaseSuffix = -beta
    prereleaseSuffix = -rc
    prereleaseSuffix = -pre

[merge]
        # ff = false

[color]
        ui = 1

[diff]
        tool = vimdiff

[difftool]
        prompt = no

[alias]
        aliases = !git config --name-only --list | grep ^alias | cut -d'.' -f 2 | sort
        branches = branch -a
        remotes = remote -v
        stashes = stash list
        tags = tag -l -n1 --sort="version:refname"

        initialcommit = commit --allow-empty -m 'Initial commit'

        path = rev-parse --show-toplevel
        s = status -s
        pwb = symbolic-ref --short HEAD

        l = log -10 --oneline
        ll = log -10 --abbrev-commit --date=format:'%y-%m-%d %H:%M' --format='tformat:%C(auto)%h %ad %s'

        discard = "!git reset --hard HEAD; \
            git status -s; \
            git status -s | grep --quiet '^?' && echo && echo 'There are remaining untracked files in your project.';"

        rollbackkk = reset --mixed HEAD^
        rollback-to = reset --hard
        prunetags = fetch --prune origin '+refs/tags/*:refs/tags/*'

        rstash = "! \
            _help () { \
                echo 'Like git stash, but remote.'; \
                echo 'usage: git rstash list'; \
                echo '   or: git rstash save [-m <message>] (Note: always save untracked files)'; \
                echo '   or: git rstash apply <name>'; \
            } ; \
            _save() { \
                [ $(git status -s | wc -l) = '0' ] && echo 'No local changes to save' && return; \
                local wip=$(git symbolic-ref --short HEAD); \
                local rstashbranch=rstash__$(date -u '+%Y%m%d-%H%M')__${wip}; \
                local message=\"${1:-rstashed}\"; \
                git add . \
                && git stash push -m \"WIP ${message}\" \
                && git push origin stash@{0}:refs/heads/${rstashbranch} \
                && git stash drop \
                && git push origin ${wip} ; \
            } ; \
            _apply() { \
                local branch=; \
                [ $1 ] && branch=$1; \
                [ -z $branch ] && echo 'Choose a branch' && return 1; \
                git checkout $branch \
                && git reset HEAD^ \
                && git add . \
                && git stash push -m \"$(git log --format='%s' -1 HEAD@{1})\" \
                && git checkout - \
                && git stash pop \
                && git reset HEAD . \
                && echo '' \
                && echo 'Remote stash applied.' ; \
            } ; \
            _list() { \
                git branch -a --list *rstash* ; \
            } ; \
            _() { \
                [ -z $1 ] && _help && return; \
                [ $1 = list ] && _list && return; \
                [ $1 = save ] && _save \"$3\" && return; \
                [ $1 = apply ] && _apply $2 && return ; \
            } ; \
            _"

        pullc = !git fetch --tag --prune origin && git merge origin/$(git rev-parse --abbrev-ref HEAD) $(git rev-parse --abbrev-ref HEAD)

        pushc = "! \
            for remote in $(git remote | grep -v -e 'deploy' -e 'upstream'); do \
                echo; echo; \
                echo '['$remote']'; \
                git push --tags $remote $(git rev-parse --abbrev-ref HEAD); \
            done"

[core]
        autocrlf = input
        editor = vim
[http]
        sslVerify = false
[push]
        default = matching

[commit]
        template = ~/projects/gitconfig/files/git_commit_template.txt

[rebase]
        autosquash = true
